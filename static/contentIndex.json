{"Game-Dev-&-Graphics/Noise-(TODO)":{"title":"Noise (TODO)","links":[],"tags":[],"content":"…\nPerlin Noise (TODO) §\n\nMinecraft\nFlow Fields\n\nCoding Challenge #24: Perlin Noise Flow Field - YouTube\n\n\n\nVoronoi (TODO) §\n…"},"Game-Dev-&-Graphics/Procedural-Generation-(TODO)":{"title":"Procedural Generation (TODO)","links":[],"tags":[],"content":"…\nWave function collapse (TODO) §\n\nHow Townscaper Works: A Story Four Games in the Making (youtube.com)\nThe Wave Function Collapse algorithm - YouTube\n\n"},"Game-Dev-&-Graphics/Quaternians":{"title":"Quaternians","links":[],"tags":[],"content":"\nDon’t Get Lost in Deep Space: Understanding Quaternions - Technical Articles (allaboutcircuits.com)\nQuaternion - Wikipedia\n"},"Game-Dev-&-Graphics/Shaders-(TODO)":{"title":"Shaders (TODO)","links":[],"tags":[],"content":"…\n\nThe Book of Shaders\nIntroduction to shaders: Learn the basics!\n"},"Game-Dev-&-Graphics/UI-Strategies-(TODO)":{"title":"UI Strategies (TODO)","links":[],"tags":[],"content":"Immediate vs Retained UI §\n\nImmediate-Mode Graphical User Interfaces - 2005 (youtube.com)\nImmediate Mode vs Retained Mode – oandre.gal\nImmediate UI vs Retained UI - Collin Quinn’s Portfolio (collquinn.gitlab.io)\nYou don’t need DOM to do UI (youtube.com)\n"},"HCI-&-VR/basics":{"title":"basics","links":[],"tags":[],"content":"…"},"Hardware/Basics":{"title":"Basics","links":["Hardware/CPU-(TODO)"],"tags":[],"content":"Generally speaking there are a few pieces’ of hardware you need, and will be found in basically every machine\n\n\nGPU (often optional or integrated into CPU); What actually renders frames to the monitor that you see. This can be a “discrete gpu” (one you buy and install), or integrated GPU where the GPU is built into the CPU\n\n\nResources\n\n\n(5) CPUs vs GPUs As Fast As Possible - YouTube\n\n\n(6) CPU vs GPU (What’s the Difference?) - Computerphile - YouTube\n\n\n\n\n\n\nMotherboard; This is essentially what connects all of your components. There are tons of specs to talk about with motherboards but generally speaking you will want to select motherboards based on the fact you are going to be limited to the chipset the CPU you are using is compatible with.\n\n\nResources\n\n\n(8) Motherboards Explained - YouTube\n\n\n(8) What is a Chipset as Fast As Possible - YouTube\n\n\n(8) How Motherboards Work - Turbo Nerd Edition - YouTube\n\n\n\n\n\n\nRAM (primary Volatile storage); This is where your system will store temporary data, such as data that apps need to run\n\n\nVolatile implies that it requires electricity to store it’s data, this means when the electricity stops runing through it all the data is lost. This is handy because it means that if you get an error and shutdown your PC you know your RAM will be cleared\n\n\nThe capacity of RAM determines how much multitasking you can do. Generally speaking if you run out of RAM you will be unable to run new processes (not always true [check out page files])\n\n\nFrequency, this is measured in MHz and is how many bits/s can be sent on one line. This is not a catch-all for speed however and should be balanced with channels and timings\n\n\nMemory Timing; This describes a number of different measurements available, see the video below for details\n\n\nChannels (single, dual, quad); Generally speaking your motherboard will determine if your RAM should be single, dual or quad channel. It is recommended to just go with what it says, however keep in mind going with a different config can effect performance\n\n\nresources\n\nHow Do Memory Timings Work? - YouTube\n\n\n\n\n\nNon-volatile or persistant storage (HDD or SSD); This is what is used to store your files persistantly (when the PC is turned off and on)\n\n\nResources\n\n\n(7) SSDs vs Hard Drives as Fast As Possible - YouTube\n\n\n(7) Explaining SSDs: Form Factors, Interfaces &amp; Technologies - YouTube\n\n\n(7) Explaining the Difference Between SSD NVMe and M2 SATA and mSATA - YouTube\n\n\n\n\n\n\n\nNetwork Card[NIC; Network interface card] (Ethernet or wifi); This is what is used to connect to networks (such as the internet). It can be a wifi card to communicate wirelessly, or ethernet based. Typically this is included in your motherboard now, but you can have multiple NIC’s\n\n\nResources\n\n\n(7) NIC (Network Interface Card) - YouTube\n\n\n(7) What is NIC or Network Interface Card or Network Card? | TechTerms - YouTube\n\n\n\n\n\n\nSoundcard (usually integrated in motherboard); This is what generates audio for you to listen to. Generally speaking this is integrated into the motherboard, and often not required to buy seperately\n\n\nResources\n\nSound Cards, DACs, and Amps as Fast As Possible - YouTube\n\n\n\n\n\nUSB chipset; This is part of your motherboard, but often these are seperate chips that can break independent of the rest of the motherboard so I figured I would mention it:\n\n\nResources\n\n(8) An Introduction to Computer Chipsets - YouTube\n\n\n\n\n\nPSU (power supply unit); This is what actually powers all the parts of your PC\n\n\nResources\n\n\nBeginners Guide to Power Supplies… How to understand the ratings - YouTube\n\n\nHow Power Supplies Work - Turbo Nerd Edition - YouTube\n\n\n\n\n\n\nHardware Basics - YouTube\nDifferent Storage types and how they are used §\n\nNon volatile (slowest, but persistant, most space) —&gt; RAM (Faster, volatile, less space)\n—&gt; Level caches (Fastest, very volatile, least space)\n\n(5) Cache Memory Explained - YouTube\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nComponent (click for more info)DescriptionMotherboardCPU (TODO)The “brain” of the computer. This is what essentially tells your computer what to do, and helps coordinates other parts of your computerRAMSSD/HDDGPUNIC/WIFI/EthernetPeripherals"},"Hardware/CPU-(TODO)":{"title":"CPU (TODO)","links":[],"tags":[],"content":"The “brain” of the computer. This is what essentially tells your computer what to do, and helps coordinates operations between other parts of your computer. There are a few important specifications to understand:\n\n\nInstruction size; This is essentially the amount of space each instruction in a CPU has to work with. 32 bit programs will run on 32 bit and 64 bit systems, but 64 bit programs will ONLY run on 64 bit systems\n\n32Bit\n64Bit\n\n\n\nIt’s important to note 3 common architectures that are used\n\nx86; Most intel and AMD chips are x86 (often called by 86)\nARM; A lower-power architecture used in many phones and also new M series macbooks\nRISC &amp; RISC 5; An open source alternative used by some companies like IBM with the intention of simplicity of system\n\n\n\nLevel Caches; This is a system that allows a CPU to store small bits of information to process them quickly. The lower the “level”, the less storage space, but the faster it is. These are typically denoted as something like L3 (level 3) 32MB, L2 (level 2) 8MB, L1 (level 1) 3.5MB. This system is a form of Volatile storage, this implies that it requires electricity to store it’s data, this means when the electricity stops runing through it all the data is lost\n\n\nResources\n\nPutting the “you” in CPU\n32-bit vs 64-bit Computers &amp; Phones as Fast As Possible - YouTube\nARM Processor - Sowing the Seeds of Success - Computerphile - YouTube\nARM vs x86: Explained - YouTube\nHow a CPU Works in 100 Seconds // Apple Silicon M1 vs Intel i9 - YouTube\n(5) What is Cache Memory? L1, L2, and L3 Cache Memory Explained - YouTube\n[(5) What is CPU Cache? - YouTube](https://www.youtube.com/watch?v=sHqNMHf2UNI\n(5) Why do CPUs Need Caches? - Computerphile - YouTube\n\n\n\nReferences §\n\nReinventing the Processor (youtube.com)\n"},"Hardware/Connection-Types-(TODO)":{"title":"Connection Types (TODO)","links":[],"tags":[],"content":"There are tons of ways of connecting your PC to peripherals (devices outside your PC)"},"Networking-&-Webdev/HTTP-(TODO)":{"title":"HTTP (TODO)","links":[],"tags":[],"content":"\nRFC 4229 - HTTP Header Field Registrations (ietf.org)\n"},"Networking-&-Webdev/Networking-Error-Correction-(TODO)":{"title":"Networking Error Correction (TODO)","links":[],"tags":[],"content":"UDP FEC (Forward Error Correction) §\n\nUsing Forward Error Correction to Mitigate Packet Loss (f5.com)\nIs FEC-code needed for UDP? - Stack Overflow\nRFC 6363: Forward Error Correction (FEC) Framework (rfc-editor.org)\n\n"},"Networking-&-Webdev/Products-and-Services-(TODO)":{"title":"Products and Services (TODO)","links":[],"tags":[],"content":"\nTunnel | Zero Trust App Connector | Cloudflare\n"},"Networking-&-Webdev/SMTP-(TODO)":{"title":"SMTP (TODO)","links":[],"tags":[],"content":"\nSending raw email using the Amazon SES API - Amazon Simple Email Service\nParse Raw Email (MIME) Guide - SigParser\nWhy Plain Text Emails Still Work &amp; How to Use Them - Litmus\nSee the whole ‘raw’ email message in Outlook - Office Watch (office-watch.com)\nSending raw or plain email with Laravel (devinthewild.com)\nRead email messages in plain text - Microsoft Support\nView the raw email message in Gmail - The Electric Toolbox Blog\nRaw Message Format (cloudmailin.com)\n\nAdditional §\n\n37C3 - SMTP Smuggling – Spoofing E-Mails Worldwide (youtube.com)\nEmail vs Capitalism, or, Why We Can’t Have Nice Things - Dylan Beattie - NDC Oslo 2023 - YouTube\n"},"Networking-&-Webdev/Virtualization-(TODO)":{"title":"Virtualization (TODO)","links":[],"tags":[],"content":"…\nVM’s (TODO) §\n…\nContainerization (TODO) §\n…\nOrchestration &amp; Infrastructure as Code (TODO) §\n…\n\ndeclarative\nA Theory of Voluntary Cooperation (markburgess.org)\nPromise theory - Wikipedia\nelectronics-12-00942-v2.pdf\nJudge0 - Where code happens.\nTwine: Efficient, reliable cluster management - Engineering at Meta (fb.com)\n"},"OS-&-Firmware/Basics":{"title":"Basics","links":[],"tags":[],"content":"Firmware/Bios §\nWhen starting a computer your bios will run after POSTing (basically a check that happens before the bios to make sure hardware is running). This is what is called firmware. Essentially it’s code that is written directly onto the hardware that lets it start up. From there it then passes on to the bootloader:\n\n\nHow To - What is BIOS? - YouTube\n\n\nPC BIOS Settings - YouTube &lt;— Explains some basic settings\n\n\nBIOS, CMOS, UEFI - What’s the difference? - YouTube (useful to know about CMOS if you need to troubleshoot hardware)\n\n\nBootloader §\nThis then is what starts the kernel. Most importantly this is the system that when the bios talks to it can actually provide the memory location of where to start the kernel. This is important because it allows you to setup multiboot systems where more than 1 OS, and even OS’s with different kernels can be loaded:\n\n\nGRUB: GNU GRUB - Wikipedia, GNU GRUB - GNU Project - Free Software Foundation (FSF)\n\n\nrEIFIT: The rEFInd Boot Manager (rodsbooks.com)\n\n\nclover: GitHub - CloverHackyColor/CloverBootloader: Bootloader for macOS, Windows and Linux in UEFI and in legacy mode\n\n\nWindows 10 boot manager Windows 10 Boot Manager - YouTube\n\n\nKernel §\nThe kernel is what allows your operating system to talk to hardware. Generally speaking this is high-level interfaces, while all the complicated portions of the communication are handled by the drivers:\n\n\nWhat is a Kernel and what does it do? Explore the Kernels of Linux, Windows, and MacOS. - YouTube\n\n\nLinux And Windows Kernel Comparison - YouTube\n\n\n24C3: Inside the Mac OS X Kernel - YouTube\n\n\nWhat is a kernel - Gary explains - YouTube\n\n\nWrite Your Own 64-bit Operating System Kernel #1 - Boot code and multiboot header - YouTube\n\n\nDrivers §\nThis is where the magic happens. Typically drivers are talked about as seperate from the kernel because they are installed seperately, though they are typically kernal “modules”. Some drivers are part of userspace, but people often think of it as blurring the lines between kernel and userspace, not to mention some implementations actually skip the kernel entirely and just access drivers directly.\nGenerally speaking each device is going to be different, and therefore will need a different driver. Some will just work with generic drivers, but it’s usually best to run a device with it’s specific driver.\n\nWhat is a Software Driver as Fast As Possible - YouTube\n\nThe flow of data §\nTo start a system it looks like:\n\nHardware —&gt; Talks to Firmware/bios —&gt; talks to bootloader —&gt; talks to kernel\n—&gt; Starts operating system\nonce started the flow looks more like:\n\n Hardware —&gt; Kernel —&gt; Userspace (what you see and all the processes you see running including windows managers, desktop environments, user management, etc.)\nSo for example if you have a frame from a video game first the hardware would generate the frame, it would then send it via the graphics driver to the display server, which would then render it through the Desktop environment/window manager"},"OS-&-Firmware/Userspace":{"title":"Userspace","links":[],"tags":[],"content":"This is the good old operating system you know and love. This is where applications, your desktop, and %90 of computing is done.\n\n(5) The Layman’s Guide to Linux: User Space - YouTube (Covers most things at once, but I would recommend doing other sections first then come back to this video)\n\nPackage managers §\nThese systems are designed to help a user manage packages (applications and services that run on an OS). These are common on linux systems, but less common on windows. They give advantages over just normally just installing applications because you can manage versions, updates, and uninstalling more easliy:\n\n\napt, dpkg, git, Python PiP (Linux Package Management) // Linux for Hackers // EP 5 - YouTube\n\n\nThe APT Package Manager in Debian and Ubuntu - YouTube\n\n\nWindows Package Manager | Microsoft Docs\n\n\nThe Missing Package Manager for macOS (or Linux) — Homebrew\n\n\nChocolatey Software | Chocolatey - The package manager for Windows\n\n\nThere is an alternative to package managers that are essentially containerized forms of package managers:\n\n\nSnapcraft - Snaps are universal Linux packages\n\n\nFlatpak—the future of application distribution\n\n\nDistro’s §\nDistro’s or distributions is the name given to different “flavours” of operating systems (really only applies to linux since there’s 1 version of macos and 1 version of windows). A distro is what you actually install to your computer and includes a kernel, and all the default userspace packages and configurations.\nThere are many different distro’s, but generally there are some groups of “similar” ones that do thing in a similar way and have similar setups. Packages can have a wide range of formats and which ones are supported is often tied to the type of distro you use\nDebian §\nThe most popular type of linux distro. Can use raw binaries or .deb files for packages. Typically uses apt as a package manager:\n\n\nZorinOS: Zorin OS - Make your computer better.\n\n\nMint: Home - Linux Mint, Linux Mint · GitHub\n\n\nUbuntu: Enterprise Open Source and Linux | Ubuntu\n\n\nCutefish: CuteFishOS - A Clean Mac-Like Linux Desktop - YouTube\n\n\nParrot: Parrot Security\n\n\nKali: Kali Linux | Penetration Testing and Ethical Hacking Linux Distribution\n\n\nPOP!: Pop!_OS by System76\n\n\nElementary: The thoughtful, capable, and ethical replacement for Windows and macOS ⋅ elementary OS\n\n\nArch §\nConsidered to be the bleeding edge, and also typically the hardest learning curve. Tends to use pacman in conjunction with AUR (Arch user repository) to get it’s packages:\n\n\nManjaro: Manjaro\n\n\nEndeavour: EndeavourOS – A terminal-centric distro with a vibrant and friendly community at its core\n\n\nReborn: Homepage rebornos - RebornOS\n\n\nFedora §\nOften considered the more “corporate” type of distro:\n\nFedora (getfedora.org)\n\nLFS (Linux from scratch) §\nLinux from scratch is exactly what it sounds like. You build your system from nothing and basically create “your own distro”\n\n\nWelcome to Linux From Scratch!\n\n\nLinux From Scratch - Wikipedia\n\n\nProcesses §\nA running program. They are essentially enclosed processes that have a bunch of state. When a process is made it will have a PID you can use to identify the process. While each process is seperate you can technically “pipe” the contents of processes between each other, typically using STDIN and STDOUT:\n\n\nLinux Internals - Process Management - YouTube\n\n\nLinux processes, init, fork/exec, ps, kill, fg, bg, jobs - YouTube\n\n\nTerminal/Shell §\nThe shell is the name given to the system that lets you start and stop processes. The terminal is just the visualization of the shell that you interact with. When you start processes via clicking on a shortcut this still goes through the shell, but you likely won’t see the terminal representation.\nShells:\n\n\nBash; Bash (Unix shell) - Wikipedia, Bash - GNU Project - Free Software Foundation\n\n\nZSH; Z shell - Wikipedia, Zsh\n\n\nFish: fish shell\n\n\nTerminals\n\n\nOh My Zsh - a delightful &amp; open source framework for Zsh\n\n\nTermux; Termux | Terminal emulator and Linux environment for Android.\n\n\nCmder; cmderdev/cmder: Lovely console emulator package for Windows (github.com)\n\n\nwarp: Warp: The terminal for the 21st century\n\n\nAlacritty: alacritty/alacritty: A cross-platform, OpenGL terminal emulator. (github.com)\n\n\nAdditional references\n\n\nThe Terminal vs The Shell - YouTube\n\n\nTerminal Basics\n\n\nIntroduction to Basic Linux Commands - YouTube\n\n\nBash in 100 Seconds - YouTube\n\n\nBatch/Cmd Programming: Lesson 1 (Basics) - YouTube\n\n\nBash Shell Scripting Tutorial For Beginners - Bash Basics in 20 Minutes - YouTube\n\n\nMicrosoft PowerShell for Beginners - Video 1 Learn PowerShell - YouTube\n\n\nStreams §\nStreams is the name given to the system used to communicate with processes through the shell. There are 2 main types (and also STDERR you can look into yourself)\n\nSTDIN §\nThe INput stream that the terminal and commands use\nSTDOUT §\nThe OUTput stream that is what you as a user often read when a command is finished\nPiping §\nYou can PIPE the output (stdout) of one command (command1), or some text to the input (stdin) of another command (command2):\ncommand1 | command2\nThis means command2 will run using the output of command1 as input\nSudo/permissions §\nSome folders and files are locked to “admins”, on linux you need to use the command sudo to allow access. On windows you need to use the gui prompt.\nFile System §\nThis is the system that is used to keep track of your files. People use this term to refer to multiple things (including both the way things are stored, and the file structure itself), but this just simply refers to the actual process of how your files are stored.\nFurther on we will talk about the file system structures that are common on operating systems, and that is not about how something is stored, but where things are commonly stored (though sometimes people still just call it the file system)\n\n(5) Files &amp; File Systems: Crash Course Computer Science #20 - YouTube\n“The ZFS filesystem” - Philip Paeps (LCA 2020) (youtube.com)\n\nFile System Structure §\nThis is the standard used to describe where you should look in a file system for certain things (i.e. installed apps, default configurations etc.)\n\n\nLinux Directories Explained in 100 Seconds - YouTube\n\n\nLinux File System/Structure Explained! - YouTube\n\n\n(5) Linux vs Windows File System Structure Compared! - YouTube\n\n\n[Environment variables](Terminal Basics (kieranwood.ca)) (These often get used to make finding certain paths easier)\n\n\nFile System Formats §\nThis is the way in which the file system actually stores it’s data. This can impose limitations (like 4Gb file size limits for FAT32) and enable features (rolling backups/snapshots for BTRFS for some setups) depending on which you chose:\n\n\nNTFS vs FAT32 vs exFAT - Everything You Need To Know - YouTube\n\n\n(5) File Systems | Which One is the Best? ZFS, BTRFS, or EXT4 - YouTube (Bit opinionated, particularly about raid)\n\n\n(5) Introduction to the Ext4 File System for Linux - YouTube\n\n\n(5) File Systems as Fast As Possible - YouTube\n\n\nDisplay Server §\nControls what you actually see, without this nothing will render to the screen (examples are x server and wayland). In order for a GUI to appear whatever application is running will need to run through the display server\n\n\nX Window System - YouTube\n\n\nWayland vs Xorg | Learn which one to choose - YouTube\n\n\nDesktop Environments §\nThe name given to the collection of systems that run to give a linux distribution it’s “look and feel”. This includes things like a start menu (or not), a search bar (or not), desktop icons (or not), taskbar/app dock (or not), the file explorer and many other features that make a distribution look and feel different. Note that sometimes distro’s with the same desktop environment will look different because they can often be styled with custom themes using CSS.\n\n\nGNOME, a very popular DE: GNOME – Simple, beautiful, elegant.\n\n\nKDE Plasma: Plasma - KDE Community\n\n\nCinnamon: Cinnamon (desktop environment) - Wikipedia, video\n\n\nMATE: MATE Desktop Environment | MATE (mate-desktop.org)\n\n\nXFCE: Xfce Desktop Environment\n\n\nCutefish: CutefishOS – Cutefish OS Built on Ubuntu (cutefish-ubuntu.github.io), How to install Cutefish Desktop in Ubuntu and derivatives (linuxcool.net)\n\n\nWindow Manager §\nControls the borders of GUI windows [the minimize, maximize and close buttons], as well as their positions and dimensions. These are usually part of desktop environments but you can install custom ones:\n\nWindow manager used by GNOME: Enlightenment Main\nA fun tiling window manager I used to use in my edgy arch linux days: https://github.com/qtile/qtile\nAnother Tiling window manager: https://i3wm.org/\nAwesome: https://awesomewm.org/\n\nFile Manager §\nWhat allows you to visually traverse your file system\n\n\nNemo: Nemo (file manager) - Wikipedia,source\n\n\nDolphin: Dolphin - KDE Applications\n\n\nNautilus (GNOME): GNOME / Files · GitLab\n\n\nHelpful reference videos §\n\n\nBrief Introduction to Computing Systems - User Space Processes, Shells, Kernels, and Hardware - CS1 - YouTube\n\n\nUnix system calls (1/2) - YouTube &amp; Unix system calls (2/2) - YouTube\n\n"},"Security-&-Cryptography/Basics":{"title":"Basics","links":[],"tags":[],"content":"\n(A Detailed Guide to Digital Forensics: Tools, Scope, Jobs, and Competition | LinkedIn\n"},"Security-&-Cryptography/Samir-Secret-Sharing-(TODO)":{"title":"Samir Secret Sharing (TODO)","links":[],"tags":[],"content":"\nA beginner’s guide to Shamir’s Secret Sharing | by Keyless Technologies | Medium\nShamir’s secret sharing - Wikipedia\nShamir’s Secret Sharing Algorithm | Cryptography - GeeksforGeeks\n\n"},"Security-&-Cryptography/Whitehat,-Grey-Hat,-and-Black-Hat-Hacking":{"title":"White, Grey & Black Hat Hacking","links":[],"tags":[],"content":"When Talking about hacking there’s a few different common terms that come up. These terms convey the intent, permission &amp; motivations behind the way someone is hacking.\nLegality §\nAll hacking (including white hat) can be illegal in various ways, so don’t think just because you pick one of these that you’re free of legal scrutiny 1 2. This changes over time, and per country, but you should look into your legal risk before doing any work on systems in particular for any situation you should:\n\nAsk permission first before trying an exploit.\n\nImportantly you need to get in writing that you’re allowed to do what you’re doing. Even if someone hires you there should be a record, or they can say they never gave you permission.\n\n\nDisclose all exploits\n\nIf you come across an exploit while intentionally or unintentionally using an application you should disclose it. The two common types are responsible disclosure, and full3. Many places will have bug bounty programs exactly for this4 5\n\n\nDO NOT COLLECT DATA\n\nIf you are able to get data from a system do not store it. Storing stolen data is illegal in pretty much every country, especially user data\n\n\n\nDoing all of this does not guarantee you legal immunity, it’s just the best practices to avoid most legal issues. Some countries have stronger stances on this 6 7 than others8 and that will effect legality a lot as well.\nTypes of Disclosures §\nIt’s important to note when disclosing bugs there are 2 main types, public/full and responsible/private. Their names should give you some indication, but essentially a full disclosure is a disclosure of a bug publicly 9 10 11. The philosophy of this is that people deserve to know their devices are vulnerable. By disclosing publicly it forces the company to resolve the issues, unlike private disclosures, which can often take years and can lead to ”catch and kill“.\nPrivate/responsible disclosures instead will report directly to the hardware/software developer directly so they can fix it without the knowledge of the public. This is often done through bug bounty programs where people are paid to find bugs. This also has the benefit of not allowing black hat hackers to use a bug while the developer is patching it.\nThere is a more in depth article on the ethics here.\nWhite Hat §\nThese are typically considered the “good guys”, the intention is to discover security vulnerabilities to help the affected systems, and importantly doing all this while they have permission to do so. White hat hackers would include people who are part of security analysis teams\nJust because white hat hackers have permission does not always mean they are free from legal issues. For example a polish train service hired hackers to look into issues with a train when their warranty expired, and they are now being threatened by the manufacturer12. Likewise agents working for governments of one country do not have permission from other countries for their work, and may find themselves being charged if they enter those countries.\nExamples §\n\nCompanies that offer to do paid penetration testing\n\nPenetration Testing Services | Pentesting | HackerOne\nPenetration Testing Services for Security | BreachLock\nWhite-hacking Services - White Hat Hacker Company - Enterprise Security - Kiss Software\n\n\nPolish Train DRM\n\nTechnical Details\nAdditional Sources, and legal threats\n\nTrains were designed to break down after third-party repairs, hackers find | Ars Technica\nHackers Hit With Legal Threats After They Fixed a ‘Bricked’ Polish Train (gizmodo.com)\n\n\n\n\n\nGrey Hat §\nThis is essentially where you are hacking “for good”, in a legally or ethically ambiguous way. This is someone for example who is working on a system without explicit permission. This means that you are operating in a “grey-area”, since you don’t intend to do something wrong, but this doesn’t mean you are in the clear.\nSome countries will “upgrade” grey hat hacking to white hat hacking if people follow responsible disclosure paths 6 13. These laws change by country, but in some countries it is “safe” to test an exploit so long as you can demonstrate it’s sole purpose was to then disclose it to the company. Different countries have varying rules on this, but generally if you write up a disclosure (like a CVE) you can avoid the legal consequences. Realistically you should just go the “white hat” approach first, and reach out before testing, however if you accidentally find a vulnerability in many cases you should be protected so long as you disclose it to the company that makes the software or hardware you’re using.\nExamples §\n\nGoogle cloud hacking\n\nGoogle Online Security Blog: Google Cloud Awards $313,337 in 2022 VRP Prizes (googleblog.com)\nHacking Google Cloud? (youtube.com)\n\n\nZuckerberg Facebook page hack\n\nZuckerberg’s Facebook page hacked to prove security exploit | CNN Business\n\n\nDan Kaminsky discovering Sony rootkit\n\nSony Numbers Add Up to Trouble (archive.org)\nSony BMG Rootkit Scandal: 10 Years Later | CSO Online\n\n\nTweetDeck XSS Vulnerability\n\nTweetDeck vulnerability lets attackers execute code remotely - The Verge\nThe breaches continued: Twitter’s TweetDeck Hacked | Indusface Blog\nTweetdeck vulnerability found by teen trying to code emoji heart | X | The Guardian\nHere’s how that major Tweetdeck vulnerability works - Vox\n\n\nStuxnet\n\nAn Unprecedented Look at Stuxnet, the World’s First Digital Weapon | WIRED\nStuxnet explained: The first known cyberweapon | CSO Online\nWhat Is Stuxnet? | Trellix\n\n\n\nBlack hat §\nBlack hat hackers are essentially the “bad” side of hacking. This is people who are hacking illegally with the intention to be paid to exploit, and or sell exploits. Basically all forms of black hat hacking are illegal, including the less obvious forms like social engineering. It’s also important to be aware that in some countries even purchasing vulnerabilities can be considered illegal.\nExamples §\n\nNHS ransomware attacks\n\nNHS ransomware attack spreads worldwide - PMC (nih.gov)\nUK battles hacking wave as ransomware gang claims ‘biggest ever’ NHS breach | TechCrunch\nNHS ransomware attack: what happened and how bad is it? | Cybercrime | The Guardian\n\n\nEbay 2016 XSS attacks\n\nXSS Flaw Exposed eBay Users to Phishing Attacks - SecurityWeek\nHackers still exploiting eBay’s stored XSS vulnerabilities in 2017 | Netcraft\neBay Falls Victim to Cross-Site Scripting Attack (bitdefender.com)\n\n\nSammy worm\n\nThe MySpace Worm that Changed the Internet Forever (vice.com)\nThe Tale of Samy The Worm.. One of the greatest moments in hacking… | by Niall Leah | Medium\nSamy (computer worm) - Wikipedia\n\n\n\nAdditional Reference and resources §\n\nHacker’s Grimoire - Hacker’s Grimoire (gitbook.io)\nLiveOverflow - YouTube\nJohn Hammond - YouTube\n\nFootnotes §\n\n\nIt’s Now Scary to Be A White Hat Hacker Thanks to the US Government (futurism.com) ↩\n\n\nMERKBLATT White Hat Hacker EN.pdf ↩\n\n\nhttps://www.helpnetsecurity.com/2023/11/27/eddie-zhang-project-black-vulnerability-disclosure ↩\n\n\nGoogle Bug Hunters ↩\n\n\nMicrosoft Bounty Programs | MSRC ↩\n\n\nUS Justice Department won’t prosecute white-hat hackers under the CFAA | ZDNET ↩ ↩2\n\n\nBelgium legalises ethical hacking: a threat or an opportunity for cybersecurity? - CiTiP blog (kuleuven.be) ↩\n\n\nLicense to hack? - Ethical hacking - Infosecurity Magazine (infosecurity-magazine.com) ↩\n\n\nmisc.ktemkin.com/fusee_gelee_nvidia.pdf ↩\n\n\nCVE - CVE (mitre.org) ↩\n\n\nZuckerberg’s Facebook page hacked to prove security exploit | CNN Business ↩\n\n\nhttps://gizmodo.com/hackers-hit-with-legal-threats-after-they-fixed-a-brick-1851097424 ↩\n\n\nhttps://www.justice.gov/opa/pr/department-justice-announces-new-policy-charging-cases-under-computer-fraud-and-abuse-act#:~:text=The%20policy%20for%20the%20first%20time%20directs%20that%20good%2Dfaith%20security%20research%20should%20not%20be%20charged. ↩\n\n\n"},"events/GDG-YYC":{"title":"GDG YYC","links":[],"tags":[],"content":"Notes from GDG YYC 2023, a google conference in Calgary Alberta.\nGoogle’s latest experiments in Labs\nAI §\n…\n\nGoogle AI\n\nFoundations §\n\nAttention is All You Need – Google Research\n\nModels &amp; Tools §\n…\nGen AI studio §\n…\nGenerative AI Studio (google.com)\nMediapipe §\nMediaPipe  |  Google for Developers\nMaker Suite §\nMakerSuite  |  PaLM API  |  Generative AI for Developers\nDuet AI §\n…\nIntroducing Duet AI for Google Workspace | Google Workspace Blog\nVertex AI §\n…\nOverview of Generative AI on Vertex AI  |  Google Cloud\nUse cases\n\nSearch for documents/website\nChatbot/support bot\n\nBard §\n…\nPaLM2 §\n\nText generation\nGoogle AI: What to know about the PaLM 2 large language model (blog.google)\nGoogle AI PaLM 2 – Google AI\nPathways language model\npapers\n\n[2204.02311] PaLM: Scaling Language Modeling with Pathways (arxiv.org)\nPathways Language Model (PaLM): Scaling to 540 Billion Parameters for Breakthrough Performance – Google Research Blog\npalm2techreport.pdf (ai.google)\n\n\n\nDensely activated\n\n2207.02073v1.pdf (arxiv.org)\nDense Connections Explained | Papers With Code\n\n\nFew shot learning\n\nFew-Shot Learning | Papers With Code\nFew-shot learning - Wikipedia\nWhat Is Few Shot Learning? (Definition, Applications) | Built In\n\n\nUses compute optimal scaling compared to palm 1\n4 sizes\n\nsmallest runs on phone (gecko)\n\n\nPaLM powers bard and google workspace\nUse cases\n\nMed-PaLM (research.google)\nGoogle Launches Generative AI for Cybersecurity (analyticsvidhya.com)\n\n\nData toxicity\n\nRacism\nsexism\netc.\nGoogle I/O 2023: PaLM 2 Debut Shows Language Model Progress (futurumgroup.com)\n[2309.06415] Down the Toxicity Rabbit Hole: Investigating PaLM 2 Guardrails (arxiv.org)\n\n2309.06415v2.pdf (arxiv.org)\n\n\nGoogle’s PaLM 2 paper shows that text-generating AI still has a long way to go | TechCrunch\nThe Real-World Harms of LLMs, Part 2: When LLMs Do Work as Expected (arthur.ai)\n\n\n\nGemini §\n\nWhat is Google Gemini? The next-generation AI model explained (trustedreviews.com)\n\nImagen §\n…\ntext-to image\nChirp §\n…\ntext-to-speech and vice-versa\nCodey §\n…\ncode\nEmbeddings §\n…\ntake image and text content and be able to search through it\nClaude 2 §\nAnthropic \\ Claude 2\nCloud/Devops/ Platform engineering §\n…\nInstead of devops where a request comes in, something is setup and then each group has their own setup you have more of a self-service option that has standardized solutions.\nFor example in a typical devops solution a team would request version control management, the devops team spins up and configured GitLab for their request, and if they want to use Jenkins as a CI/CD runner then Jenkins is setup for them ad-hoc.\nIn a platform engineering solution a team would fill out a form and pick the standard tool to instantiate (GitLab in this case), then they request to implement Jenkins into GitLab, which then is built out as a standard solution which can be used for any and all teams that want them. In this way the platform itself is a self-service product that allows people to pick what they want, then the devops team helps work with clients to build out solutions, then platform engineers will maintain the platform and it’s standard services.\n\nBadal.io\n\nStartups §\n\nGoogle for Startups Cloud Program  |  Google Cloud\nStart, build, grow: Tools, resources and support programs for startups - Google for Startups\nWhat Matters: What is an OKR? OKR Meaning, Definition &amp; Examples | What Matters\nUse OKRs to Set Goals for Teams, Not Individuals (hbr.org)\n"},"index":{"title":"Welcome!","links":["/"],"tags":[],"content":"Welcome to my computer science KB. The purpose of this project is to be a knowledge base for all things computer science. Most of this is information I have come across and used. The information is broken up into various sections by field to make it easy to find things, but also don’t be afraid to use the search bar since the site has full-text search to make finding whatever you need as easy as possible!\nAbout Me §\nHi 👋, I’m Kieran.\nI’m currently a computer science student with a minor in philosophy at the university of Calgary in Canada. I’ve been developing since I started my degree professionally as both a freelancer and full-time employee, as well as doing open source work. If you’re interested in some of my other projects check out some of the links in the footer of the site!"},"programming/Binary-and-Hexadecimal-(TODO)":{"title":"Binary and Hexadecimal (TODO)","links":[],"tags":[],"content":"Binary §\n…\nOperations in Binary §\n…\nAddition §\n…\nSubtraction §\n…\nMultiplication §\n…\nDivision §\n…\nOther Novel uses §\n…\nBinary Enumeration §\n…\nBooleans §\n…\nHexadecimal §\n…\nOperations in Hex §\n…\nAddition §\n…\nSubtraction §\n…\nMultiplication §\n…\nDivision §\n…\nOther Novel uses §\n…\nAddressing §\n…"},"programming/Compilers-(TODO)":{"title":"Compilers (TODO)","links":[],"tags":[],"content":"Steps:\n\nLexer/Tokenizer: Break up code into smallest meaningful pieces. For python the code\ndef myfunc(x):\\n\\tprint(x)\nmight be broken up into a list of:\n[def, myfunc, (, x, ), :, \\t, print, (, x, ) ]\nParser: Take the tokens and turn them into something logical. For example with our def myfunc(x):\\n\\tprint(x) we might have a parser that generates a tree that looks like this (JSON format):\n\n{function:\n       {\n           label:myfunc,\n           args:[x],\n           body:[\n               callFunction:{\n                   label:print,\n                   args:[x]\n               }\n          ]\n      }\n}\n\nCode Generator:\n\nIt’s important to note this approach is common, but not complete. There are many steps other compilers will take in addition to these steps.\nLexer/Tokenizer §\nWe define our language syntax, we could think of this as a map of some text to a meaningful token. Something like:\n&quot;def&quot; -&gt; Start of Function\n&quot;&quot;\n\nAn approach\nReferences §\n\nA Compiler From Scratch (destroyallsoftware.com)\n"},"programming/Garbage-Collection-(TODO)":{"title":"Garbage Collection (TODO)","links":[],"tags":[],"content":"Algorithms and Theory §\n\nMark-and-Sweep: Garbage Collection Algorithm - GeeksforGeeks\nStatic single-assignment form - Wikipedia\n\nModern Day implementations §\nV8 (Node JS, Chromium browsers) §\n\nTrash talk: the Orinoco garbage collector · V8\nHigh-performance garbage collection for C++ · V8\nGarbage collection in V8, an illustrated guide | by Irina Shestak | Medium\nsmol-zines/guides/garbage-collection-in-v8.md at main · lrlna/smol-zines (github.com)\nv8-perf/gc.md at master · thlorenz/v8-perf (github.com)\nJavaScript garbage collection: Browser vs. server - LogRocket Blog\nJavaScript Internals: Garbage Collection | AppSignal Blog\n\nPython §\n\nPython Garbage Collection: What It Is and How It Works (stackify.com)\nGarbage Collection in Python - GeeksforGeeks\ngc — Garbage Collector interface — Python 3.12.0 documentation\n"},"programming/HTML-(TODO)":{"title":"HTML (TODO)","links":[],"tags":[],"content":"\nHTML Standard (whatwg.org)\n\n"},"programming/Speculation-&-Branch-Prediction-(TODO)":{"title":"Speculation & Branch Prediction (TODO)","links":[],"tags":[],"content":"\nBranch predictor - Wikipedia\nSpeculation in JavaScriptCore | WebKit\n\nSecurity Concerns (TODO) §\n\nMeltdown and Spectre (meltdownattack.com)\nMeltdown and Spectre (spectreattack.com)\nSpectre and Meltdown explained: A comprehensive guide for professionals | TechRepublic\nSpectre (security vulnerability) - Wikipedia\nMeltdown (security vulnerability) - Wikipedia\n4 years since Sperctre vulnerability discovery | Kaspersky official blog\nIntel’s AMD bug find proves that Spectre is still looming over us - The Verge\nComputer scientists discover new vulnerability affecting computers globally | ScienceDaily\nAffected Processors: Transient Execution Attacks &amp; Related Security… (intel.com)\n"},"programming/index":{"title":"Basics","links":["programming/python"],"tags":[],"content":"This section will talk about basic programming concepts, if you want the easiest way to start programming I would look into the python section, which will detail how to use python for all these concepts.\nPseudocode §\nFor this section I will use Pseudocode, this is a fancy name for “I don’t want to write real code”. Essentially it will be a mix of code syntax and plain English to make it easy to read.\nVariables (TODO) §\n…\nData Types (TODO) §\n…\nBooleans (TODO) §\n…\nInteger (TODO) §\n…\nFloat/Floating Point (TODO) §\n…\nArray’s &amp; Lists (TODO) §\n…\nMappings (dictionaries, hash-maps, associative arrays) §"},"programming/python":{"title":"python","links":["/"],"tags":[],"content":"Python is a versatile and widely-used programming language that is used by developers, data scientists, and educators alike. Created by Guido van Rossum and first released in 1991, Python has steadily grown in popularity due to its simplicity and readability. Its design philosophy emphasizes code readability, making it an ideal choice for both beginners and experienced programmers. Python’s ease of use, combined with its robust libraries and frameworks, has made it a top choice for a wide range of applications, from web development and data analysis to artificial intelligence and scientific computing.\nOne of Python’s key strengths is its extensive standard library (largely housed on PyPi), which provides a wide array of modules and packages that simplify tasks such as file handling, machine learning, networking, web development and even graphical user interface (GUI) development. Python’s versatility extends to its cross-platform compatibility, as it can be run on various operating systems, including Windows, macOS, and Linux. Furthermore, its open-source nature fosters a vibrant community of developers who continuously contribute to its growth, ensuring that Python remains at the forefront of programming languages.\nPython’s reputation as a go-to language for data science and machine learning has skyrocketed in recent years. Libraries like NumPy, pandas, and scikit-learn empower data scientists to efficiently manipulate and analyze data, while frameworks like TensorFlow and PyTorch provide powerful tools for building and training machine learning models. Likewise Flask, FastAPI, and Django are web development frameworks that have become staples of modern web development. Python’s simplicity, combined with these libraries and frameworks, has made it a driving force in the rapidly evolving fields of artificial intelligence and data-driven decision-making. In summary, Python’s blend of simplicity, versatility, and a thriving ecosystem make it a language of choice for developers across a wide spectrum of disciplines, making it a timeless and invaluable tool in the world of programming.\nCREATING AND USING FILES §\nCreating and using Python files, also known as Python scripts, is the foundation of writing and running Python programs. Here’s a beginner-friendly explanation of how to get started:\nINSTALLING PYTHON §\n\nBefore you start creating Python files, you need to have Python installed on your computer. You can download it from the official Python website (https://www.python.org/downloads/).\nFollow the installation instructions for your operating system.\n\nEDITING PYTHON CODE §\n\nYou can write Python code using a simple text editor (like Notepad on Windows or TextEdit on macOS) or use specialized Python IDEs (Integrated Development Environments) like Visual Studio Code, PyCharm, or IDLE.\nChoose the option that suits you best. IDEs provide additional features to make coding easier.\n\nCREATING A PYTHON FILE §\n\nIn your chosen text editor or IDE, create a new file. To do this, go to “File” &gt; “New” or press Ctrl+N (Windows) or Cmd+N (macOS).\nSave the file with a .py extension, which indicates it’s a Python script. For example, you can save it as my_script.py.\n\nWRITING YOUR FIRST PYTHON CODE §\n\nIn your newly created Python file, you can start writing Python code. Here’s a simple “Hello, World!” example:\n\nprint(&quot;Hello, World!&quot;)\n\nThis code uses the print() function to display “Hello, World!” on the screen.\n\nRUNNING YOUR PYTHON SCRIPT §\n\nTo run your Python script, you need to open a terminal or command prompt.\nNavigate to the directory where your Python file is located using the cd command (e.g., cd Documents if your file is in the “Documents” folder).\nThen, type python followed by the name of your Python file and press Enter:\n\npython my_script.py\n\nYour Python script will execute, and you’ll see the output in the terminal.\n\nEDITING AND SAVING CHANGES §\n\nYou can make changes to your Python file by opening it in your text editor or IDE, editing the code, and saving the file (usually by pressing Ctrl+S or Cmd+S).\nAfter saving, you can rerun the script to see the updated results.\n\nLEARNING AND EXPERIMENTING §\n\nPython is a versatile language with many features and libraries. You can learn by exploring Python tutorials, books, or online courses.\nAs you learn, you can create more complex Python scripts to perform various tasks, from simple calculations to building web applications or analyzing data.\n\nThat’s the basic process of creating and using Python files. Start with simple scripts like “Hello, World!” and gradually build your skills by tackling more advanced projects. Python is known for its readability and simplicity, making it an excellent choice for beginners to start their coding journey.\nVARIABLES &amp; TYPES §\nPython is a versatile programming language that can work with various types of data. Here’s a basic overview of three fundamental data types: int, float, and str. These 3 data types help to make up most of the basic operations you will do.\nINTEGERS (INT) §\nIntegers are whole numbers, which means they don’t have any decimal points.\n\nYou can use integers for counting, indexing, and performing arithmetic operations like addition and subtraction.\nFor Example: 5, -10, 1000\n\nmy_integer = 42print(my_integer)  # Output: 42\nFLOATING-POINT NUMBERS (FLOAT) §\n\nFloating-point numbers, or floats, are numbers that can have decimal points.\nYou use floats when you need to represent values with precision, such as measurements or calculations involving fractions.\nExample: 3.14, -0.5, 2.0\n\nmy_float = 3.14159print(my_float)  # Output: 3.14159\nSTRINGS (STR) §\n\nStrings are sequences of characters, like text or words, enclosed in single (’ ‘), double (” “), or triple (’’’ ’’’ or ””” “””) quotes.\nYou can manipulate strings, concatenate them (combine them), and perform various operations like searching for specific characters.\nExample: &#039;Hello, World!&#039;, &quot;Python is fun&quot;, &#039;&#039;&#039;Triple-quoted strings&#039;&#039;&#039;\n\nmy_string = &quot;Hello, World!&quot;print(my_string)  # Output: Hello, World!\nThese three basic data types are the building blocks for most Python programs. You can perform operations on them, combine them, and use them to represent different kinds of data in your code. As you continue to learn Python, you’ll discover more data types and ways to work with them, but these are the essential ones to get started.\nCOLLECTIONS §\nIf you are not familiar you can find details about what collections are here.\nPython provides two common collection types, lists, and tuples. These collection types allow you to store multiple values in a single variable.\nLists §\n\nA list is an ordered collection of items.\nYou can store various types of data in a list, such as numbers, strings, or even other lists.\nLists are mutable, which means you can change their contents (add, remove, or modify elements).\n\nCreating a List: To create a list, use square brackets [] and separate the items with commas.\nmy_list = [1, 2, 3, &quot;apple&quot;, &quot;banana&quot;]\nAccessing Elements: You can access individual elements in a list by their position, called an index. Python uses zero-based indexing, so the first element is at index 0.\nfirst_item = my_list[0]  # Gets the first item (1)second_item = my_list[1]  # Gets the second item (2)\nModifying a List: You can change, add, or remove items from a list.\nmy_list[3] = &quot;cherry&quot;  # Modifies an item (changes &quot;apple&quot; to &quot;cherry&quot;)my_list.append(4)  # Adds an item to the end (appends 4)my_list.remove(&quot;banana&quot;)  # Removes an item (removes &quot;banana&quot;)\nTuples §\n\nA tuple is similar to a list, but it is immutable, meaning you cannot change its elements once it’s created.\nTuples are typically used when you want to create a collection of items that should not be modified.\n\nCreating a Tuple: To create a tuple, use parentheses () and separate the items with commas.\nmy_tuple = (1, 2, 3, &quot;apple&quot;, &quot;banana&quot;)\nAccessing Elements: You access tuple elements in the same way as with lists, using zero-based indexing.\nfirst_item = my_tuple[0]  # Gets the first item (1)second_item = my_tuple[1]  # Gets the second item (2)\nImmutable Nature: You cannot change the elements of a tuple after creation. Attempting to do so will result in an error.\nmy_tuple[3] = &quot;cherry&quot;  # This will raise an error (Tuples are immutable)\nWhen to Use Lists vs. Tuples:\n\nUse lists when you need a collection of items that can change over time.\nUse tuples when you want to create a collection of items that should remain constant.\n\nHere’s a simple summary: Lists are like dynamic containers where you can put different things and change them, while tuples are like sealed containers where you put things that won’t change. Both are valuable tools in Python, and your choice depends on your specific needs in a program.\nFUNCTIONS §\nIf you are not familiar you can find details about what functions are here.\nPython functions are like mini-programs or reusable blocks of code that perform specific tasks. Think of them as functions in math, where you input something, and it gives you a result. In Python, you can create your own functions to perform tasks you need. Here’s a beginner-friendly explanation:\nDEFINING A FUNCTION §\n\nTo create a function, you use the def keyword, followed by the function name and parentheses (). You can also include parameters (input values) inside the parentheses.\n\ndef greet(name):    print(&quot;Hello, &quot; + name + &quot;!&quot;)\n\nIn this example, we defined a function called greet that takes one parameter, name.\n\nCALLING A FUNCTION §\n\nOnce you’ve defined a function, you can use it by calling it. To call a function, you simply write its name followed by parentheses and any necessary arguments (values for the parameters).\n\ngreet(&quot;Alice&quot;)\n\nThis line of code calls the greet function and passes &quot;Alice&quot; as the name parameter.\n\nRETURN VALUES §\n\nFunctions can also return a result using the return keyword. This is like the answer you get from a math function.\n\ndef add(a, b):    result = a + b    return result\n\nIn this example, the add function takes two parameters, a and b, adds them together, and returns the result.\n\nsum_result = add(5, 3)print(sum_result)  # Output: 8\n\nHere, we call the add function with 5 and 3 as arguments and store the result in the sum_result variable.\n\nREUSABILITY §\n\nFunctions make your code more organized and reusable. You can use the same function multiple times throughout your program.\n\nSCOPE §\n\nVariables defined inside a function have local scope, meaning they can only be accessed within that function. Variables outside the function have global scope, which means they can be used throughout your code.\n\nBUILT-IN FUNCTIONS §\n\nPython also comes with many built-in functions, like print(), len(), and input(), which you can use without having to define them yourself.\n\nHere’s a simple summary: Functions in Python allow you to define a set of instructions that can be used over and over again. They take input, perform actions, and can return results. Functions are like handy tools you create to make your coding tasks easier and more organized.\nCONTROL FLOWS §\nPython control flows, especially the if statement, help you make decisions in your code. Think of them as instructions to your program to perform certain actions based on conditions. Let’s break it down in a beginner-friendly way:\nTHE IF STATEMENT §\n\nThe if statement is used to make decisions in Python.\nIt allows your program to execute different code blocks depending on whether a condition is true or false.\n\nBASIC IF SYNTAX §\n\nThe basic structure of an if statement looks like this:\n\nif condition:    # Code to execute if the condition is True\n\nThe condition is an expression that evaluates to either True or False.\n\nTRUTHINESS §\n\nIn Python, many things can be considered either “truthy” or “falsy.” This means that they can be evaluated as equivalent to True or False in a boolean context.\nCommon truthy values include non-zero numbers, non-empty strings, and non-empty containers (like lists or dictionaries).\nCommon falsy values include 0, an empty string &quot;&quot;, and empty containers.\n\nBOOLEAN LOGICAL COMPARISONS §\n\n\nYou can compare values using boolean logical operators to create conditions in your if statements.\n\n\nCommon boolean operators are:\n\n== (equal): Checks if two values are equal.\n!= (not equal): Checks if two values are not equal.\n&lt; (less than): Checks if one value is less than another.\n&gt; (greater than): Checks if one value is greater than another.\n&lt;= (less than or equal to): Checks if one value is less than or equal to another.\n&gt;= (greater than or equal to): Checks if one value is greater than or equal to another.\n\n\n\nExample:\nx = 5y = 10 if x &lt; y:    print(&quot;x is less than y&quot;)\n\nIn this example, the if statement checks if x is less than y. If it’s true, it prints “x is less than y.”\n\nELSE AND ELIF (ELSE-IF) STATEMENTS §\n\nYou can extend if statements with else and elif (else-if) statements to handle multiple conditions.\n\nExample:\nage = 20 if age &lt; 18:    print(&quot;You are underage.&quot;)elif age &gt;= 18 and age &lt; 65:    print(&quot;You are an adult.&quot;)else:    print(&quot;You are a senior citizen.&quot;)\n\nIn this example, the code checks different conditions based on the age variable and prints an appropriate message.\n\nNESTED IF STATEMENTS §\n\nYou can also nest if statements inside other if statements to handle more complex conditions.\n\nExample:\nx = 5 if x &gt; 0:    if x % 2 == 0:        print(&quot;x is a positive even number.&quot;)    else:        print(&quot;x is a positive odd number.&quot;)else:    print(&quot;x is not a positive number.&quot;)\n\nIn this example, we have nested if statements to determine whether x is positive and even or positive and odd.\n\nIn summary, if statements allow your Python program to make decisions based on conditions. You can use boolean operators to create conditions, and you can include else and elif statements for more complex decision-making. This is a fundamental building block for creating dynamic and responsive code in Python.\nLOOPS §\nPython loops are used to repeatedly execute a block of code. They allow you to automate repetitive tasks by running the same code multiple times. Let’s explore Python loops in a beginner-friendly way:\nThe for Loop §\n\nA for loop is used when you know how many times you want to repeat a certain action. It’s often used to iterate over a sequence, such as a list or a range of numbers.\n\nBasic for Loop Syntax:\nfor variable in sequence:    # Code to execute in each iteration\n\nvariable represents an item from the sequence in each iteration, and sequence is the collection of items to loop through.\n\nExample:\nfruits = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;] for fruit in fruits:    print(fruit)\n\nIn this example, the for loop iterates through the fruits list and prints each fruit one by one.\n\nThe while Loop §\n\nA while loop is used when you want to repeat a block of code as long as a certain condition is true. It’s often used when you don’t know in advance how many times the loop will run.\n\nBasic while Loop Syntax:\nwhile condition:    # Code to execute as long as the condition is True\n\nThe loop will continue running as long as condition remains True.\n\nExample:\ncount = 0 while count &lt; 5:    print(&quot;Count: &quot;, count)    count += 1\n\nIn this example, the while loop prints the value of count as long as it’s less than 5, incrementing count in each iteration.\n\nLoop Control Statements §\n\nYou can control the flow of loops using special statements:\n\nbreak: Terminates the loop prematurely.\ncontinue: Skips the current iteration and moves to the next.\n\n\n\nExample (using break):\nnumbers = [1, 2, 3, 4, 5, 6] for num in numbers:    if num == 4:        break  # Exit the loop when num is 4    print(num)\n\nIn this example, the loop stops when num becomes 4, and the code after the loop continues executing.\n\nExample (using continue):\nnumbers = [1, 2, 3, 4, 5, 6] for num in numbers:    if num % 2 == 0:        continue  # Skip even numbers    print(num)\n\nIn this example, the loop skips even numbers and continues to the next iteration.\n\nPython loops are powerful tools for automating repetitive tasks and processing data. By understanding for and while loops and how to control their flow, you can make your programs more dynamic and efficient.\nDEFINING YOUR OWN TYPES §\nIn Python, classes are like blueprints for creating objects. Think of a class as a template that defines the properties (attributes) and behaviors (methods) that objects of that class will have. Let’s break down Python classes in a beginner-friendly way:\nCLASS DEFINITION §\n\nTo create a class, you use the class keyword, followed by the name of the class (usually starting with a capital letter).\n\nclass Dog:    # Class definition goes here\n\nIn this example, we’ve defined a class called Dog.\n\nATTRIBUTES §\n\nAttributes are variables that store data within a class. They represent the characteristics or properties of objects created from the class.\n\nclass Dog:    breed = &quot;Unknown&quot;  # Attribute to store the dog&#039;s breed    age = 0           # Attribute to store the dog&#039;s age\n\nIn this class, breed and age are attributes that every dog object will have.\n\nMETHODS §\n\nMethods are functions defined within a class. They represent the actions or behaviors that objects of the class can perform.\n\nclass Dog:    breed = &quot;Unknown&quot;    age = 0     def bark(self):        print(&quot;Woof! Woof!&quot;)     def fetch(self):        print(&quot;Fetching the ball...&quot;)\n\nIn this class, bark() and fetch() are methods that represent the actions a dog can do.\n\nCREATING OBJECTS (INSTANCES) §\n\nTo use a class, you create objects (instances) from it. An object is a specific instance of a class.\n\nmy_dog = Dog()  # Creating an instance of the Dog class\n\nmy_dog is now an object of the Dog class.\n\nACCESSING ATTRIBUTES AND METHODS §\n\nYou can access attributes and methods of an object using dot notation (object_name.attribute or object_name.method()).\n\nmy_dog.breed = &quot;Golden Retriever&quot;  # Setting the breed attributemy_dog.age = 3                    # Setting the age attribute print(&quot;My dog is a&quot;, my_dog.breed)  # Accessing the breed attributemy_dog.bark()                       # Calling the bark method\n\nHere, we’ve set the breed and age attributes and called the bark() method on my_dog.\n\nCONSTRUCTOR METHOD (__INIT__) §\n\nThe __init__ method is a special method in Python classes. It’s called when you create an object from the class and is used to initialize attributes.\n\nclass Dog:    def __init__(self, breed, age):        self.breed = breed        self.age = age     def bark(self):        print(&quot;Woof! Woof!&quot;)\n\nWhen you create a Dog object, you need to provide values for breed and age.\n\nmy_dog = Dog(&quot;Golden Retriever&quot;, 3)\n\nThis way, you can create a dog object with specific attributes during its creation.\n\nThat’s the basic idea of Python classes! Classes allow you to define a blueprint for creating objects with specific attributes and behaviors. They help you organize your code in a structured and reusable way, which is especially useful for building complex applications.\nType hints §\nType hints are a way in python to specify the intended type of a variable (not enforced just highly suggested). This works by having a colon, then the type declaration for each varaible/parameter/attribute. You can even include details about return types in functions with def function_name(parameter) -&gt; return_type For example:\n \nage = 21\n \n  \n \ndef greet(name):\n \n   return f&quot;Hello {name}&quot;\n \n  \n \nclass Animal:\n \n   def __init__(self, name):\n \n      self.name = name\n \nCan be converted to:\n \nage:int = 21\n \n  \n \ndef greet(name:str) -&gt; str:\n \n   return f&quot;Hello {name}&quot;\n \n  \n \nclass Animal:\n \n   def __init__(self, name:str):\n \n      self.name:str = name\n \nThis gives an indication to people running your code which data types they should use. Along with this there are a few special types to keep in mind (most need to be imported from the typing module):\n| Type | Usage | Example |\n|------|-------|---------|\n| Union | To indicate one type OR another | A variable called age which can be a string or int could be given as age:Union[str,int] = &quot;Twenty Three&quot; |\n| Literal | The avlue for the variable is literally one of the subscripted values | x is 2, 4 or 6 only x:Literal[2,4,6] |\n| Tuple | A tuple is an imutable data type similar to a list, this can mean a tuple, or is used to indicate multiple return values | The function func() returns an int and a bool in that order def func() -&gt; Tuple[int, bool |\n| List | A list is a collection. Collections can be subscripted to tell you what’s inside | users is a list of list of strings users:List[List[str]] = [[&quot;kieran&quot;],[&quot;James&quot;]]\n| Callable | This means any object that has a __call__() method including functions (yes they are objects) | Passing the function do_stuff() to time(func:Callable) so it can run it and time it time(do_stuff) |  \nEnforcing types §\nPython does not enforce types on function parameters. But you can make your own type enforcement by doing type comparisons. There are two ways to do this. The first is to use type() and compare to the class, for example:\n \ndef greet(name:str) -&gt; str:\n \n  if not type(name) == str:\n \n    raise ValueError(f&quot;{name} is not a string&quot;)\n \n  return f&quot;Hello {name}&quot;\n \n  \n \nclass Animal:\n \n  def __init__(self, name:str):\n \n    self.name:str = name\n \n  \n \ndef show_animal(animal:Animal):\n \n  if not type(animal) == Animal:\n \n    raise ValueError(f&quot;{animal} is not an Animal&quot;)\n \n  return f&quot;This animal is a {animal.name}&quot;\n \nThis method works ok, but it’s not the best. For example let’s say you have a class that extends the str class, it would fail that check:\n \nclass MyString(str):\n \n  def __init__(self,value:str):\n \n    if not type(value) == str:\n \n      raise ValueError(f&quot;{value} is not a string&quot;)\n \n    self.value = value\n \n  \n \n  def __str__(self) -&gt; str:\n \n    return self.value  \n \n  \n  \n \ndef greet(name:str) -&gt; str:\n \n  if not type(name) == str:\n \n    raise ValueError(f&quot;{name} is not a string&quot;)\n \n  return f&quot;Hello {name}&quot;\n \n  \n \ngreet(MyString(&quot;Kieran&quot;)) # ValueError: Kieran is not a string\n \nIf we want to include subclasses we should use isinstance():\n \nclass MyString(str):\n \n  def __init__(self,value:str):\n \n    if not type(value) == str:\n \n      raise ValueError(f&quot;{value} is not a string&quot;)\n \n    self.value = value\n \n  \n \n  def __str__(self) -&gt; str:\n \n    return self.value  \n \n  \n  \n \ndef greet(name:str) -&gt; str:\n \n  if not isinstance(name, str):\n \n    raise ValueError(f&quot;{name} is not a string&quot;)\n \n  return f&quot;Hello {name}&quot;\n \n  \n \ngreet(MyString(&quot;Kieran&quot;)) # Hello Kieran\n \nHere are some good types you can use with isinstance() that are more general:\n|Type|Uses|package|\n|----|----|-------|\n| Number | All number types (int and float) work with it |numbers.Number|\n| Iterable | Any type that can be iterated (a for loop works on it) | Iterable |\n| Callable | Any type that can be called with parenthesis () (like function objects) | Callable |\nFor example:\n \nfrom numbers import Number\n \nprint(isinstance(1,Number)) # True\n \nprint(isinstance(1.2,Number)) # True\n \nprint(isinstance(1j,Number)) # True\n \n  \n \nfrom typing import Iterable\n \nprint(isinstance([],Iterable)) # True\n \nprint(isinstance(&quot;&quot;,Iterable)) # True\n \nprint(isinstance({},Iterable)) # True\n \n  \n \nfrom typing import Callable\n \n  \n \ndef greet(name:str) -&gt; str:\n \n  if not isinstance(name, str):\n \n    raise ValueError(f&quot;{name} is not a string&quot;)\n \n  return f&quot;Hello {name}&quot;\n \n  \n \nis_str = lambda s: isinstance(s, str) # Anonymous function\n \n  \n \nclass SquareNum:\n \n    def __init__(self, num:Number):\n \n        if not isinstance(num, Number):\n \n            raise ValueError(f&quot;{num} is not a Number&quot;)\n \n        self.num=num\n \n    def __call__(self) -&gt; Number:\n \n        return self.num *self.num\n \n  \n \nprint(isinstance(greet, Callable)) # True\n \nprint(isinstance(is_str, Callable)) # True\n \nprint(isinstance(SquareNum, Callable)) # True\n \n  \n \nWhile this works there are even better solutions. Pydantic is a python package that’s designed to help make data validation easy. The package helps with a few things, but mostly it helps solve a very annoying situation that happens constantly. When you get data from a server it will often come down as JSON, which will be converted to a python dictionary. These dictionaries can sometimes be very large. Here’s an example from their website:\n \n  \n \nfrom pydantic import BaseModel, PositiveInt\n \nclass User(BaseModel):\n \n    id: int  \n \n    name: str = &#039;John Doe&#039;  \n \n    signup_ts: datetime | None  \n \n    tastes: dict[str, PositiveInt]  \n \n  \n  \n \nexternal_data = {\n \n    &#039;id&#039;: 123,\n \n    &#039;signup_ts&#039;: &#039;2019-06-01 12:22&#039;,  \n \n    &#039;tastes&#039;: {\n \n        &#039;wine&#039;: 9,\n \n        b&#039;cheese&#039;: 7,  \n \n        &#039;cabbage&#039;: &#039;1&#039;,  \n \n    },\n \n}\n \n  \n \nuser = User(**external_data)  # Valid data, creates without issue NOTE: cabbage will have int(1) as value not str(&quot;1&quot;)\n \n  \n \nexternal_data = {&#039;id&#039;: &#039;not an int&#039;, &#039;tastes&#039;: {}}  \n \n  \n \nUser(**external_data)  # Invalid data, raises ValidationError\n \nThere are some more strict systems you can use if you want to enforce static typing (checking before you run code). The most popular is mypy, which throws errors if you try to run code that might have the wrong type. There’s also a newer library called pyre from meta (formerly facebook) which has a playground you can test with.\nThere’s a few others:\n\n\nGoogle Pytype\n\n\nMicrosoft Pyright\n\n\nPacking and Unpacking §\nWhen looking at collections you can “unpack” them. This basically allows you to break them up into peices. For example:\n \nshopping_list = [&quot;eggs&quot;, &quot;ham&quot;, &quot;spam&quot;]\n \n  \n \nitem1, *remainders = shopping_list\n \n  \n \nprint(item1) # &#039;eggs&#039;\n \nprint(remainders) # [&#039;ham&#039;, &#039;spam&#039;]\n \nThe *remainder will “unpack” values. This basically will “consume” collections. So item1 will access the first item in the list, and *remainders will unpack the remaining values into it. This can be used in a ton of situations, one major one is to unpack variables as parameters for functions. So for example let’s say someone has a tuple with coordinates coords = (x, y, z), and a function process_object(x, y, z), we can unpack the coords variable into the function:\n \ncoords = (x, y, z)\n \nprocess_object(*coords) # Same as process_object(x, y, z)\n \nYou can also use this to do the oposite and “pack” values to allow for any number of parameters in a function (they will be put into a tuple):\n \ndef function(*parameters):\n \n  print(parameters)\n \n  \n \nfunction(1, 2, 3, 4, 5) # Prints: (1, 2, 3, 4, 5)\n \nYou could then unpack them using *:\n \ndef function(*parameters):\n \n  print(*parameters)\n \n  \n \nfunction(1, 2, 3, 4, 5) # Prints: 1 2 3 4 5\n \nYou can also do this with dictionaries, but it’s more complex. It will allow you to get the keys and values from a dictionary. So one useful case is combining two dictionaries. For example let’s say you have some of your user info in one dict, and some in another that you want to combine:\n \nuser_info_1 = {\n \n  &quot;id&quot;: 1,\n \n  &quot;first_name&quot;: &quot;Dene&quot;,\n \n  &quot;last_name&quot;: &quot;Atwill&quot;,\n \n}\n \n  \n \nuser_info_2 = {\n \n  &quot;first_name&quot;: &quot;Dene&quot;,\n \n  &quot;email&quot;: &quot;datwill0@wordpress.com&quot;,\n \n  &quot;gender&quot;: &quot;Male&quot;,\n \n  &quot;ip_address&quot;: &quot;38.119.114.174&quot;\n \n}\n \n  \n \nuser_info = {**user_info_1, **user_info_2} # {&#039;id&#039;: 1, &#039;first_name&#039;: &#039;Dene&#039;, &#039;last_name&#039;: &#039;Atwill&#039;, &#039;email&#039;: &#039;datwill0@wordpress.com&#039;, &#039;gender&#039;: &#039;Male&#039;, &#039;ip_address&#039;: &#039;38.119.114.174&#039;}\n \nAdditionally this can be used to capture keyword arguments:\n \ndef function(**keyword_arguments):\n \n  print(keyword_arguments)\n \n  \n \nfunction(first_name= &quot;Dene&quot;, last_name=&quot;Atwill&quot;) # prints: {&#039;first_name&#039;: &#039;Dene&#039;, &#039;last_name&#039;: &#039;Atwill&#039;}\n \nOne great use for this is that it will allow you to write a function that allows you to pass config variables to a function, and you never have to change the function signatures to support new config variables!\nMagic/dunder methods §\nMagic/dunder methods are special types of methods that have some sort of special functionality in python. They’re often called magic methods, but they’re also called dunder (double underscore) methods because they all follow the patern __&lt;name&gt;__(). If you’ve created a class before you’ve actually used one before __init__(). Why can’t you have an initialize method just called init() or start()? Because __init__() is reserved as a name and is invoked when the code that creates an instance is called, which is why it works at all.\nThere are tons of other existing dunder methods to interact with various aspects of python.\nPrinting §\nFor example let’s say you have a User class, when you try to print it to the console you will get something like &lt;__main__.User object at 0x0000017CC4F90310&gt;. This isn’t super useful, so how could we instead override what prints when we call print on an object? Let’s say we have a name and age attribute, and we want to print &lt;name&gt;: &lt;age&gt;.\nThere is a built in magic method called __repr__() (I believe this is a short version of representation), this allows you to override the representation of the object (which is what’s printed). All we need to do is return a string with what we want to print, for example:\n \nclass User:\n \n    def __init__(self, name, age):\n \n      self.name = name\n \n      self.age = age\n \n    def __repr__(self):\n \n      return f&quot;{self.name}: {self.age}&quot;\n \n  \n \nprint(User(&quot;Kieran&quot;, 24)) # Prints: &quot;Kieran: 24&quot;\n \nConversions §\nThere are tons of magic methods you can define to convert between types. These will also apply in implicit conversions (i.e. when printing something a call to convert the object into a string happens). These methods tend to follow this pattern when defined:\n \ndef __&lt;type&gt;__(self):\n \n  return value\n \nWhere type is some type (i.e. str, int, float), and value is some value of that type (i.e. &quot;Class&quot;, 12, 3.14). Let’s say for example we have a class (MyValue), that class takes in an int or float, and then when casted to a string returns the word representation of a number (i.e. 1 would be &quot;One&quot;), and other number types (int,float return that type of data):\n \n# Define lists of words for numbers 1-19 and multiples of 10 up to 90 (used in string conversion)\n \nones = [&quot;Zero&quot;, &quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;, &quot;Four&quot;, &quot;Five&quot;, &quot;Six&quot;, &quot;Seven&quot;, &quot;Eight&quot;, &quot;Nine&quot;, &quot;Ten&quot;, &quot;Eleven&quot;, &quot;Twelve&quot;, &quot;Thirteen&quot;, &quot;Fourteen&quot;, &quot;Fifteen&quot;, &quot;Sixteen&quot;, &quot;Seventeen&quot;, &quot;Eighteen&quot;, &quot;Nineteen&quot;]\n \ntens = [&quot;&quot;, &quot;Ten&quot;, &quot;Twenty&quot;, &quot;Thirty&quot;, &quot;Forty&quot;, &quot;Fifty&quot;, &quot;Sixty&quot;, &quot;Seventy&quot;, &quot;Eighty&quot;, &quot;Ninety&quot;]\n \n  \n \nclass MyValue:\n \n    def __init__(self, value):\n \n      if not type(value) in [float, int]:\n \n        # Try to cast invalid values into a float\n \n        value = float(value)\n \n      self.value = value\n \n  \n \n    def __int__(self):\n \n      # Returns a int representation of the object\n \n      return int(self.value)\n \n  \n \n    def __float__(self):\n \n      # Returns a float representation of the object\n \n      return float(self.value)\n \n    ###### Defining helper functions to help with the string conversion ######\n \n  \n \n    def convert_less_than_hundred(self, number):\n \n        # Function to convert a number less than 100 to text\n \n        if number &lt; 20:\n \n            return ones[number]\n \n        else:\n \n            return tens[number // 10] + &quot; &quot; + ones[number % 10]\n \n  \n \n    def convert_less_than_thousand(self, number):\n \n        # Function to convert a number less than 1_000 to text\n \n        if number &lt; 100:\n \n            return self.convert_less_than_hundred(number)\n \n        else:\n \n            if number % 100 == 0:\n \n                return ones[number // 100] + &quot; Hundred&quot;\n \n            else:\n \n                return ones[number // 100] + &quot; Hundred and &quot; + self.convert_less_than_hundred(number % 100)\n \n    def convert_less_than_million(self, number):\n \n        # Function to convert a number less than 1_000_000 to text\n \n        thousands = number // 1000\n \n        remainder = number % 1000\n \n        if remainder == 0:\n \n            return self.convert_less_than_thousand(thousands) + &quot; Thousand&quot;\n \n        else:\n \n            return self.convert_less_than_thousand(thousands) + &quot; Thousand &quot; + self.convert_less_than_thousand(remainder)\n \n    def convert_less_than_billion(self, number):\n \n        # Function to convert a number less than 1_000_000_000 to text\n \n        if number &gt;= 1_000_000_000:\n \n            raise ValueError(f&quot;Number provided is too large (only up to billions accepted) recieved: {number}&quot;)\n \n        millions = number // 1000000\n \n        remainder = number % 1000000\n \n        if remainder == 0:\n \n            return self.convert_less_than_thousand(millions) + &quot; Million&quot;\n \n        else:\n \n            return self.convert_less_than_thousand(millions) + &quot; Million &quot; + self.convert_integer_to_text(remainder)\n \n    def convert_integer_to_text(self, number):\n \n        # Takes in an integer, and converts it to text\n \n        if not isinstance(number, int): # Confirm value is an int\n \n            raise ValueError(f&quot;Value not an integer {number}&quot;)\n \n        # Handle simple &amp; edge cases cases\n \n        if number == 0:\n \n            return &quot;Zero&quot;\n \n        elif number &lt; 0:\n \n            return &quot;Negative &quot; + self.convert_integer_to_text(-1 * number)\n \n  \n \n        # Handle 1-999\n \n        elif number &lt; 1000:\n \n            return self.convert_less_than_thousand(number)\n \n  \n \n        # Handle 1000-999_999\n \n        elif number &lt; 1_000_000:\n \n            return self.convert_less_than_million(number)\n \n  \n \n        # Handle 1_000_000-999_999_999\n \n        else:\n \n            return self.convert_less_than_billion(number)\n \n  \n \n    ###### End of Defining helper functions to help with the string conversion ######\n \n  \n \n    def __str__(self):\n \n        # Returns a string representation of the object\n \n        number = self.value\n \n        # Handle float input\n \n        if isinstance(number, float):\n \n            # Split into part before decimal (integer_part) and after (fractional_part)\n \n            integer_part, fractional_part = str(number).split(&#039;.&#039;)\n \n  \n \n            # Convert each part to a str\n \n            integer_text = self.convert_integer_to_text(int(integer_part))\n \n            fractional_text = &quot; &quot;.join([ones[int(n)] if int(n) &gt; 0 else &quot;Zero&quot; for n in fractional_part])\n \n            # Combine if fractional_text exists, else skip and return just integer part\n \n            if fractional_text:\n \n                return integer_text + &quot; point &quot; + fractional_text\n \n            else:\n \n                return integer_text\n \n  \n \n        # Handle integer input\n \n        elif isinstance(number, int):\n \n            return self.convert_integer_to_text(number)  \n \nWe can then test this with:\n \n# Test converting integers to strings\n \nprint(str(MyClass(1))) # Prints: &#039;One&#039;\n \nprint(str(MyClass(10))) # Prints: &#039;Ten&#039;\n \nprint(str(MyClass(20))) # Prints: &#039;Twenty Zero&#039;\n \nprint(str(MyClass(12))) # Prints: &#039;Twelve&#039;\n \nprint(str(MyClass(45))) # Prints: &#039;Forty Five&#039;\n \nprint(str(MyClass(375))) # Prints: &#039;Three Hundred and Seventy Five&#039;\n \nprint(str(MyClass(5_231))) # Prints: &#039;Five Thousand Two Hundred and Thirty One&#039;\n \nprint(str(MyClass(25_231))) # Prints: &#039;Twenty Five Thousand Two Hundred and Thirty One&#039;\n \nprint(str(MyClass(954_231))) # Prints: &#039;Nine Hundred and Fifty Four Thousand Two Hundred and Thirty One&#039;\n \nprint(str(MyClass(8_954_231))) # Prints: &#039;Eight Million Nine Hundred and Fifty Four Thousand Two Hundred and Thirty One&#039;\n \nprint(str(MyClass(85_954_231))) # Prints: &#039;Eighty Five Million Nine Hundred and Fifty Four Thousand Two Hundred and Thirty One&#039;\n \nprint(str(MyClass(345_954_231))) # Prints: &#039;Three Hundred and Forty Five Million Nine Hundred and Fifty Four Thousand Two Hundred and Thirty One&#039;\n \nprint(str(MyClass(999_999_999))) # Prints: &#039;Nine Hundred and Ninety Nine Million Nine Hundred and Ninety Nine Thousand Nine Hundred and Ninety Nine&#039;\n \n  \n \n# Test converting floats to strings\n \nprint(str(MyClass(1.0))) # Prints: &#039;One point Zero&#039;\n \nprint(str(MyClass(10.15))) # Prints: &#039;Ten point One Five&#039;\n \nprint(str(MyClass(20.2))) # Prints: &#039;Twenty Zero point Two&#039;\n \nprint(str(MyClass(12.34))) # Prints: &#039;Twelve point Three Four&#039;\n \nprint(str(MyClass(45.734))) # Prints: &#039;Forty Five point Seven Three Four&#039;\n \nprint(str(MyClass(375.841))) # Prints: &#039;Three Hundred and Seventy Five point Eight Four One&#039;\n \nprint(str(MyClass(5_231.9591))) # Prints: &#039;Five Thousand Two Hundred and Thirty One point Nine Five Nine One&#039;\n \nprint(str(MyClass(25_231.12345))) # Prints: &#039;Twenty Five Thousand Two Hundred and Thirty One point One Two Three Four Five&#039;\n \nprint(str(MyClass(954_231.324698))) # Prints: &#039;Nine Hundred and Fifty Four Thousand Two Hundred and Thirty One point Three Two Four Six Nine Eight&#039;\n \nprint(str(MyClass(8_954_231.5454654))) # Prints: &#039;Eight Million Nine Hundred and Fifty Four Thousand Two Hundred and Thirty One point Five Four Five Four Six Five Four&#039;\n \nprint(str(MyClass(85_954_231.45657988))) # Prints: &#039;Eighty Five Million Nine Hundred and Fifty Four Thousand Two Hundred and Thirty One point Four Five Six Five Seven Nine Eight Eight&#039;\n \nprint(str(MyClass(345_954_231.5454654))) # Prints: &#039;Three Hundred and Forty Five Million Nine Hundred and Fifty Four Thousand Two Hundred and Thirty One point Five Four Five Four Six Five Four&#039;\n \nprint(str(MyClass(999_954_231.0567646))) # Prints: &#039;Nine Hundred and Ninety Nine Million Nine Hundred and Fifty Four Thousand Two Hundred and Thirty One point Zero Five Six Seven Six Four Six&#039;\n \nprint(str(MyClass(999_999_999.9999999))) # Prints: &#039;Nine Hundred and Ninety Nine Million Nine Hundred and Ninety Nine Thousand Nine Hundred and Ninety Nine point Nine Nine Nine Nine Nine Nine Nine&#039;\n \n  \n \n# Test converting floats to ints\n \nprint(int(MyClass(1.0)))    # Prints: 1\n \nprint(int(MyClass(10.15)))  # Prints: 10\n \nprint(int(MyClass(20.2)))   # Prints: 20\n \nprint(int(MyClass(12.34)))  # Prints: 12\n \nprint(int(MyClass(45.734))) # Prints: 45\n \n  \n \n# Test converting ints to floats\n \nprint(float(MyClass(1)))  # Prints: 1.0\n \nprint(float(MyClass(10))) # Prints: 10.0\n \nprint(float(MyClass(20))) # Prints: 20.0\n \nprint(float(MyClass(12))) # Prints: 12.0\n \nprint(float(MyClass(45))) # Prints: 45.0\n \nOperators §\nOperators allows you to do operator overloading. This allows you to overwrite what happens when you use an operator (+, -, /, //, % etc.). To do this you just use the pattern of using the operator name with one argument and a return:\n \nclass DoMath:\n \n  def __init__(self, value):\n \n    self.value = value\n \n  \n \n  def __add__(self, value):\n \n    return self.value + value\n \n  \n  \n \nprint(DoMath(5) + 3)\n \nOther Operators:\n| Function name | Operator |\n|__sub__()| -|\n|__mul__()| *|\n|__floordiv__()|  //|\n|__truediv__()| /|\n|__mod__()| %|\n|__pow__()| **|\nKeep in mind you can also add an i in front of the function name to change the behaviour with assignment operators. For example __iadd__() will override behaviour for +=\nLogical Comparisons §\nLogical operators allows you to do logical operator overloading. This allows you to overwrite what happens when you use an operator (&lt;, &gt;, &lt;=, &gt;=, == etc.). To do this you just use the pattern of using the operator name with one argument and a return (must be a bool):\n \nclass CheckLessThan:\n \n  def __init__(self, value):\n \n    self.value = value\n \n  \n \n  def __lt__(self, value):\n \n    return self.value &lt; value\n \n  \n \nprint(DoMath(5) &lt; 3)\n \n| Function name | Operator |\n|__lt__()|  &lt;|\n|__le__()|  &lt;=|\n|__eq__()|  ==|\n|__ne__()|  !=|\n|__ge__()|  &gt;=|\nClass/data-structure type magic methods §\nThere are also several other dunder methods that exist for creating special types of objects including:\n\n__call__() for callable classes\n\n  - Be careful with this\n\n__getitem__() &amp; __setitem__() for key-value pairs (see example in this post)\n\n  - hash-maps\n  - dictionaries\n  - etc.\n\n__len__() for container-like structures (what len() uses)\n\n  - lists\n  - arrays\n  - linked-list\n  - doubly-linked-lists\n\n__enter__() &amp; __exit__() for context managers\n\n  - files\n  - sockets\n\n\n__iter__() &amp; __next__() for iterators\n\n\nCreating your own dunder methods §\nWhy not create your own magic methods? If you’re writing a program it seems “pythonic” to create your own magic methods that can be used by an API (I did this for this project, where I created __html__() to turn a class into HTML). There is an implicit danger with doing this though.\nThe PSF (group that makes python) reserves the right to create whatever of these dunder methods they want. This means something like __html__() if it ever gets imlemented in python natively will break my app. So if you rely on this in your programs then python can completely break your program at any point, so you need to be careful.\nHigher order functions\nA higher order function will allow you to run code before and after a function executes. To explain how this works you need to understand that EVERYTHING in python is an object, including functions. If I look at this example:\n \ndef foo(a, b):\n \n  return b-a\n \n  \n \nprint(type(foo)) # &lt;class &#039;function&#039;&gt;\n \nWe can see the type of foo is the class function. Specifically it’s a class that runs the function body when __call__() is called. Adding a parenthesis to the end of a class causes this __call__() to happen, so foo() is a shortform for foo.__call__(). So since it’s a class we can pass it as an object the same way we could with other classes and call it later. This can help us solve some more awkward issues like timing functions.\nLet’s say we want a function we can use to measure how long a function takes to run, the basic code would look like this:\n \nimport time\n \n  \n \ndef foo(a, b):\n \n  time.sleep(.3)\n \n  return b-a\n \n  \n \nbefore = time.time()\n \nfoo(1,2)\n \nafter = time.time()\n \n  \n \ntime_taken = after-before\n \n  \n \nprint(f&quot;foo() took {time_taken}&quot;) # foo() took 0.30090832710266113\n \nSo turning this approach into a function we get:\n \nimport time\n \n  \n \ndef foo(a, b):\n \n  time.sleep(.3)\n \n  return b-a\n \n  \n \ndef time_function(function_to_time):\n \n  before = time.time()\n \n  function_to_time(1,2)\n \n  after = time.time()\n \n  time_taken = after-before\n \n  return time_taken\n \n  \n \nprint(f&quot;foo() took {time_function(foo)}&quot;) # foo() took 0.30090832710266113\n \nBut, how do we allow for people to pass arguments to the function? We could hardcode passing in 2 parameters, but what if we want to time a function with 3, or 4 parameters? We can allow a function to accept an arbitrary number of arguments to a function using *:\n \nimport time\n \n  \n \ndef foo(a, b):\n \n  time.sleep(.3)\n \n  return b-a\n \n  \n \ndef time_function(function_to_time, *args):\n \n  before = time.time()\n \n  function_to_time(*args)\n \n  after = time.time()\n \n  time_taken = after-before\n \n  return time_taken\n \n  \n \nprint(f&quot;foo() took {time_function(foo, 1, 2)}&quot;) # foo() took 0.30090832710266113\n \n*args in this case allows us to pass any number of arguments (see Packing and Unpacking for details and details about using keyword/named arguments).\nDecorators §\nDecorators are an extra layer of syntactic sugar that allow you to make higher order functions easier to work with. If we take our example of a timing function like this:\n \nimport time\n \n  \n \ndef foo(a, b):\n \n  time.sleep(.3)\n \n  return b-a\n \n  \n \ndef time_function(function_to_time, *args):\n \n  before = time.time()\n \n  function_to_time(*args)\n \n  after = time.time()\n \n  time_taken = after-before\n \n  return time_taken\n \n  \n \nprint(f&quot;foo() took {time_function(foo, 1, 2)}&quot;) # foo() took 0.30090832710266113\n \nFrom this lets say we want to always time the foo() function (for example if it was a benchmark function). We can do this by using an @ and the function name we want to wrap, and put it before the definition. In order for this to work there is an awkward step, we need to create an inner function, which runs our function:\n \nimport time\n \n  \n \ndef time_function(function_to_time):\n \n  def dummy_function(*args):\n \n    before = time.time()\n \n    function_to_time(*args)\n \n    after = time.time()\n \n    time_taken = after-before\n \n    return time_taken\n \n  return dummy_function\n \n  \n \n@time_function\n \ndef foo(a, b):\n \n  time.sleep(.3)\n \n  return b-a\n \n  \n \nprint(f&quot;foo() took {foo(1, 2)}&quot;) # foo() took 0.30090832710266113\n \nSo what just happened? When foo() runs time_function and passes itself as an instance to time_function(). Which is a fancy way to say foo() passes itself and it’s arguments to time_function(). From there we must create a closure to get our variables back. So dummy_function() exists to capture *args (positional arguments to the function [in our case 1, 2]).\nSo all in all we are running foo() with it’s arguments inside dummy_function(), we are then returning the time taken from the function, and with our decorator (the time_function()) we are returning the dummy_function to be called. So foo(1,2) calls dummy_function(1,2) and returns it’s time_taken.\nThis works great… but keep in mind that when we called foo() we got the result of time_function() NOT the function call. If we wanted the value of the function call we need to capture it in time_function(), and return it instead:\n \nimport time\n \n  \n \ndef time_function(function_to_time):\n \n  def dummy_function(*args):\n \n    before = time.time()\n \n    result = function_to_time(*args)\n \n    after = time.time()\n \n    time_taken = after-before\n \n    print(f&quot;{function_to_time.__name__}() took {time_taken}&quot;) # foo() took 0.30090832710266113\n \n    return result\n \n  return dummy_function\n \n  \n \n@time_function\n \ndef foo(a, b):\n \n  time.sleep(.3)\n \n  return b-a\n \n  \n \nfoo(1,2) # Returns 1\n \nIf we wanted to return both, we could:\n \nimport time\n \n  \n \ndef time_function(function_to_time):\n \n  def dummy_function(*args):\n \n    before = time.time()\n \n    result = function_to_time(*args)\n \n    after = time.time()\n \n    time_taken = after-before\n \n    return result, time_taken\n \n  return dummy_function\n \n  \n \n@time_function\n \ndef foo(a, b):\n \n  time.sleep(.3)\n \n  return b-a\n \n  \n \nresult, time_taken = foo(1,2) # Returns (1, 0.30090832710266113)\n \nprint(f&quot;foo() took {time_taken} and had a result of {result}&quot;) # foo() took 0.30090832710266113 and had a result of 1\n \nProperties (getters and setters) §\nProperties are a method in python to enforce the getter-setter pattern. This is more popular in languages like Java, but essentially instead of having tons of attributes that you access directly you have methods that control access to, and modification of certain attributes. This is useful for various scenarios such as:\n\n\nEnsuring a provided value is within a range when trying to set an attribute to the value\n\n\nIf a value is taken from a remote service then ensuring it is up to date when accessing\n\n\nIn asynchronus contexts it can be used to ensure locks and safe concurrent access/writes\n\n\nLet’s say for example you have an app that displays a dashboard about a city, this includes the name, population and temperature. When people access the population and temperature you want to access external services (like the city registry for population, and a weather monitor for remperature). So every time you want a bit of code to run to make sure the value being accessed is up to date. To do this you can make the attributes for temperature and population into properties. Then for each you will need a property declaration (the getter), and a setter. The getter will be used when people call City.temperature or City.population, and the setter will run when City.temperature = value or City.population = value is called.\n \nMINIMUM_TEMPERATURE_CELCIUS = -273 # Absolute zero in celcius\n \n  \n \nclass City:\n \n    def __init__(self, name, population, temperature=0):\n \n        self.name = name\n \n        self.population = population\n \n        self.temperature = temperature\n \n  \n \n    @property\n \n    def population(self) -&gt; int:\n \n        api_result = 1_000_000 # A fake call to the external API\n \n        self._population = api_result\n \n        return self._population\n \n  \n \n    @temperature.setter\n \n    def population(self, value):\n \n        # No special processing\n \n        self._population = value\n \n  \n \n    @property\n \n    def temperature(self):\n \n        print(&quot;Getting value...&quot;)\n \n        return self._temperature\n \n  \n \n    @temperature.setter\n \n    def temperature(self, value):\n \n        print(&quot;Setting value...&quot;)\n \n        if value &lt; MINIMUM_TEMPERATURE_CELCIUS:\n \n            raise ValueError(f&quot;Temperature below {MINIMUM_TEMPERATURE_CELCIUS} is not possible&quot;)\n \n        self._temperature = value\n \nSo in this case temperature() and population() are the getters, which means that when you try to access City.temperature this function is called and the result is returned. Syntax wise you need to append an underscore to access the current value. Once you have declared a property, you can then create a setter as a decorator, which would be the functions that also take in value as a parameter.\nIterators §\nWhen you use a for loop in python there is something interesting happening under the hood. Iterators are a special type of class that implements the iterator protocol. The protocol operates on classes that have two magic methods. This is what is used when you iterate. For example take this for loop:\n \nshopping_list = [&quot;eggs&quot;, &quot;ham&quot;, &quot;spam&quot;]\n \n  \n \nfor item in shopping_list:\n \n  print(item)\n \nThis can functionally be done the same with:\n \nindex = 0\n \n  \n \nwhile index &lt; len(shopping_list):\n \n  print(shopping_list[index])\n \n  index += 1\n \nYou will notice that essentially our loop calls the next item, until there are no more items. This is what the iterator is based on, it asks you to tell it what to call on each iteration (__iter__()), and then on each iteration it will call that Iterable’s __next__() function until a StopIteration exception is raised.\nCreating your own Iterator §\nWith that knowledge let’s create an iterator to understand how this works:\n \nfrom typing import List\n \n  \n \nclass ShoppingList:\n \n  def __init__(self, items:List[str]):\n \n    self.items = items\n \n    self.current_index = 0\n \n  \n \n  def __iter__(self):\n \n    return self # Shopping list is an Iterator and an Iterable\n \n  def __next__(self):\n \n    if self.current_index &lt; len(self.items):\n \n        return_value = self.items[self.current_index]\n \n        self.current_index += 1\n \n        return return_value\n \n    raise StopIteration\n \n  \n \nfor item in ShoppingList([&quot;Eggs&quot;, &quot;Ham&quot;, &quot;Spam&quot;]):\n \n  print(item)\n \nThis means you can also make Iterators out of things that don’t have a defined length. For example let’s say you have a database you’re looping through, but data is coming in while you’re looping. Instead of storing the current state and iterating over that, you can continuously keep iterating until a StopIteration is raised!\nList comprehensions §\nA list comprehension syntactically shorter way to produce a list of values with a simple calculation. It is intended to replace the design pattern of:\n\n\ninstantiating an empty list\n\n\nIterate and store values in the list\n\n\nreturn or use list values.\n\n\nFor example:\n \nresult = [] # 1. Initialize empty list\n \n  \n \n# 2. Iterate and store values in the list\n \nfor number in range(10): # Square numbers from 0-9 and add them to the result list\n \n    result.append(number**2)\n \n  \n \nprint(result) # 3. Return or use list values\n \nCan be shortened to:\n \nresult = [number ** 2 for number in range(10)] # Steps 1-2\n \n  \n \nprint(result) # 3. Return or use list values\n \nwhich produces:\n \n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n \nIt does exactly the same as the above example, it is just shorter. The basic syntax is [operation for variable in iterable] Were operation is the calculation (or function) being run, variable is the name for the temporary iteration variable made, and iterable is some form of iterable (list, generator, set etc.). We can also do this conditionally, so for example if we wanted to only include even numbers we could do:\n \nevens = [number for number in range(10) if number %2 == 0]\n \nprint(evens) # [0, 2, 4, 6, 8]\n \nAnd we can do an if-else statement using:\n \nevens = [&quot;even&quot; if number %2 == 0 else &quot;odd&quot; for number in range(10)]\n \nprint(evens) # [&#039;even&#039;, &#039;odd&#039;, &#039;even&#039;, &#039;odd&#039;, &#039;even&#039;, &#039;odd&#039;, &#039;even&#039;, &#039;odd&#039;, &#039;even&#039;, &#039;odd&#039;]\n \nGenerators §\nA generator is a type of iterator. This will allow you to make an iterator out of results of functions. For example:\n \ndef lots_of_numbers():\n \n  for number in range(10_000_000):\n \n    yield number\n \n  \n \nfor number in lots_of_numbers:\n \n  print(number)\n \nEssentially you can iterate over results 1 at a time. The question is why? Efficiency.\nIn order to iterate over 10 million numbers you would normally need to put those numbers in a list, store that list and then iterate over it. This means that data needs to be stored somewhere while iterating. With a generator the value is generated when it’s needed, and then is “paused” until next() is called on it again. So if instead of a full loop I did something like:\n \ndef lots_of_numbers():\n \n  for number in range(10_000_000):\n \n    yield number\n \n  \n \nnums = lots_of_numbers()\n \n  \n \nprint(next(nums)) # prints 0\n \nprint(next(nums)) # prints 1\n \nWhich we can run while using essentially 0 memory. We can also use generators to do memory efficient returns of different values. For example let’s say we need to get a bunch of data from an API but don’t want to have to store it all we could turn the response into a generator and only process the results one at a time. Lets say for example that get_user_orders() sends back a JSON string that we’re storing in a file:\n \ndef get_user_info():\n \n  yield get_user_name() # &quot;kieran&quot;\n \n  yield get_user_orders() # Returns a large JSON string\n \n  yield get_user_age() # 24\n \n  \n \nuser_info = get_user_info()\n \n  \n \nprint(next(user_info)) # kieran\n \nprint(next(user_info)) # prints a large JSON string\n \nprint(next(user_info)) # 24\n \nThis means we only use the memory for get_user_orders() when the second next() is called, compared to something more traditional like this:\n \ndef get_user_info():\n \n  return {\n \n    &quot;name&quot;: get_user_name(),\n \n    &quot;orders&quot;: get_user_orders(),\n \n    &quot;age&quot;: get_user_age()\n \n  }\n \n  \n \nuser_info = get_user_info()\n \n  \n \nprint(user_info) # prints a large JSON string\n \nWe need to store it in RAM the whole time!\nDataclasses §\nDataclasses are a special way to define classes in python. They help make classes more efficient, but have some caveats (that I find are positives), namely all your attributes must be defined with type hints. For example here is a User class the typical python way:\n \nclass User:\n \n   def __init__(self, name, age, birthday):\n \n      self.name = name\n \n      self.age = age\n \n      self.birthday = birthday\n \nNow here is the same class in a dataclass:\n \nfrom datetime import datetime\n \nfrom dataclasses import dataclass\n \n  \n \n@dataclass\n \nclass User:\n \n      name: str\n \n      age:int\n \n      birthday:datetime\n \nThe handy thing about this is that the birthday attribute was not clear in the original example. It could have been a 3 value tuple for year, month, day ((1998,10,28)), a formatted string &quot;28-10-1998&quot; or any other types. But now users know what type they should use (this is not enforced).\nIf you need to run code after a class instance is created you can use __post_init__(self).\n__post_init__() §\nThis is a magic method that runs after your dataclass instance is setup. So for example maybe you want to do some birthday checking to make sure someone’s birthday matches their age, and they aren’t saying they’re over 200 years old:\n \nfrom datetime import datetime\n \nfrom dataclasses import dataclass\n \n  \n \n@dataclass\n \nclass User:\n \n    name: str\n \n    age:int\n \n    birthday:datetime\n \n  \n \n    def __post_init__(self):\n \n      if self.age &gt; 200:\n \n        raise ValueError(&quot;You can&#039;t be over 200 years old &gt;:(&quot;)\n \n      if ((datetime.now().year - self.birthday.year) != self.age) and ((datetime.now().year - self.birthday.year) != self.age+1):\n \n        raise ValueError(&quot;Your birthday doesn&#039;t match your age&quot;)\n \nprint(User(&quot;Kieran&quot;, 24, datetime(1998,10,29)))\n \n  \n \n# Invalid\n \nprint(User(&quot;Kieran&quot;, 24, datetime(1864,10,5)))\n \nprint(User(&quot;Kieran&quot;, 400, datetime(2023-400,10,5)))\n \nClassVar’s §\nA class variable is a variable that exists as part of a class not part of an instance. This means each instance has the same value because it comes from the class they come from. This is handy in many situations such as keeping track of isntances that are created:\n \nfrom __future__ import annotations\n \nfrom typing import ClassVar, List\n \nfrom dataclasses import dataclass\n \n  \n \n@dataclass\n \nclass Slide:\n \n    content: str\n \n    slides: ClassVar[List[Slide]] = []\n \n  \n \n    def __post_init__(self):\n \n      Slide.slides.append(self)\n \n  \n  \n \nSlide(&quot;Hello World&quot;)\n \nSlide(&quot;World Hello&quot;)\n \nSlide(&quot;HeLlO WoRlD&quot;)\n \n  \n \nprint(Slide.slides) # [Slide(content=&#039;Hello World&#039;), Slide(content=&#039;World Hello&#039;), Slide(content=&#039;HeLlO WoRlD&#039;)]\n \nSlide.slides will now have a list of every class instance that is created, but keep in mind this means that the instances will NEVER be deleted unless you clear them out. So you might end up wasting a ton of memory. You can resolve this by having some sort of Slide.delete() method to remove itself from the list when removed:\n \nfrom __future__ import annotations\n \nfrom typing import ClassVar, List\n \nfrom dataclasses import dataclass\n \n@dataclass\n \nclass Slide:\n \n    content: str\n \n    slides: ClassVar[List[Slide]] = []\n \n  \n \n    def __post_init__(self):\n \n      Slide.slides.append(self)\n \n    def delete(self):\n \n      Slide.slides.remove(self)\n \n  \n \nSlide(&quot;Hello World&quot;)\n \nq = Slide(&quot;World Hello&quot;)\n \nSlide(&quot;HeLlO WoRlD&quot;)\n \n  \n \nprint(Slide.slides) # [Slide(content=&#039;Hello World&#039;), Slide(content=&#039;World Hello&#039;), Slide(content=&#039;HeLlO WoRlD&#039;)]\n \nq.delete()\n \nprint(Slide.slides) # [Slide(content=&#039;Hello World&#039;), Slide(content=&#039;HeLlO WoRlD&#039;)]\n \nFields §\nSome types of attributes in dataclasses need to be instantiated in more complex ways. These types require you to use field(). For example most lists will need you to use a function to instantiate it:\n \nfrom typing import ClassVar, List, Any\n \nfrom dataclasses import dataclass, field\n \n  \n \n@dataclass\n \nclass Student:\n \n  name:str\n \n  age:int\n \n  student_id: str\n \n  \n \ndef create_empty_list() -&gt; List[Any]:\n \n  return []\n \n  \n \n@dataclass\n \nclass School:\n \n  students: List[Student] = field(default_factory=create_empty_list)\n \nSo in this case the field() function takes in a default_factory which is a Callable. This is a great case for using anonymous functions/lambdas:\n \nfrom typing import ClassVar, List, Any\n \nfrom dataclasses import dataclass, field\n \n  \n \n@dataclass\n \nclass Student:\n \n  name:str\n \n  age:int\n \n  student_id: str\n \n  \n \n@dataclass\n \nclass School:\n \n  students: List[Student] = field(default_factory=lambda: [])\n \nContext managers §\nThere are many situations where you will want to have an object exist temporarily, and that object must run some code to “close” it. The most common case is files. Check out this python code:\n \nf = open(&quot;my_file.txt&quot;, &quot;w+&quot;)\n \n  \n \nf.write(&quot;some content&quot;)\n \n  \n \n... # more code\n \n  \n \nf.write(&quot;some content&quot;)\n \n  \n \n... # more code\n \n  \n \nf.write(&quot;some content&quot;)\n \nYou will notice we opened the file, wrote to it a few times, and never closed it. Lets say the code between one of the writes took a while, and someone else wanted to write to the file, what happens? In the best case the won’t be allowed to write to the file, in the worst case the changes will trample over each other, or just cause a file corruption in some cases (like if an error happens mid-write). This is why we have to close the file between writes:\n \nf = open(&quot;my_file.txt&quot;, &quot;w+&quot;)\n \nf.write(&quot;some content&quot;)\n \nf.close()\n \n  \n \n... # more code\n \n  \n \nf = open(&quot;my_file.txt&quot;, &quot;w+&quot;)\n \nf.write(&quot;some content&quot;)\n \nf.close()\n \n  \n \n... # more code\n \n  \n \nf = open(&quot;my_file.txt&quot;, &quot;w+&quot;)\n \nf.write(&quot;some content&quot;)\n \nf.close()\n \nThis is very tedious, and doesn’t guarentee you will always remember to close your file. This is where context managers come in. A context manager is an object that defines an “opening”, and “close” and will even handle if an error is raised to make sure the file is still closed anyway. You can technically call these manually, but python has a with statement that makes this easier:\n \nwith open(&quot;my_file.txt&quot;, &quot;w+&quot;) as f:\n \n  f.write(&quot;some content&quot;)\n \n  \n \n... # more code\n \n  \n \nwith open(&quot;my_file.txt&quot;, &quot;w+&quot;) as f:\n \n  f.write(&quot;some content&quot;)\n \n  \n \n... # more code\n \n  \n \nwith open(&quot;my_file.txt&quot;, &quot;w+&quot;) as f:\n \n  f.write(&quot;some content&quot;)\n \nNow f only exists in the indentation level up from the with statement! Outside that indentation level it has either not yet been opened, or been closed!\nThese are implemented with magic/dunder methods.\nCreating your own context managers §\nTo create a context manager you just need a __enter__() and __exit__() method. For example:\n \nclass MyContextManager:\n \n  def __init__(self):\n \n    ...\n \n  def __enter__(self):\n \n    print(&#039;Opened&#039;)\n \n    return self\n \n  def __exit__(self, exc_type, exc_value, exc_traceback):\n \n      print(&#039;Closed&#039;)\n \n  \n \n  def do_stuff(self):\n \n    print(&quot;Hello&quot;)\n \n  \n \nwith MyContextManager() as m:\n \n  m.do_stuff()\n \n__enter__() is self-explanatory, but __exit__() has some interesting parameters. Like I said the method will be called even if there is an error thrown. Those parameters tell you if an error occurred (if no error occurs all 3 are None):\n\n\nexc_type; The type of the error (i.e. ValueError)\n\n\nexc_value; The instance of the exception raised\n\n\nexc_traceback; The traceback object related to the error\n\n\nLambdas\nLambdas are a way in python to declare anonymous functions. What this means is you can assign a function call to a variable. So for example let’s take the simplest case, a function that takes in a name and returns a greeting string using the name:\n \ndef generate_greeting(name: str):\n \n   return f&quot;Hello {name}&quot;\n \nWe can make this a lambda like this:\n \ngenerate_greeting = lambda name: f&quot;Hello {name}&quot;\n \nLambdas follow the form of:\n \nlambda arguments: # Function body\n \nLambdas always return whatever value is evaluated in the function body. So since we evaluated the string, we get the string back at the end. We can then call it the same way:\n \ngenerate_greeting(&quot;Kieran&quot;) # &quot;Hello Kieran&quot;\n \nThis comes in handy in cases where something needs a Callable objet, but you don’t need to call it more than once. One example of this is in dataclasses. For some data types (like Lists) you need to provide a Callable object (object with a __call__() funtion) to initialize an attribute that is a list. So you can do this with a lambda that returns an empty list like so:\n \nfrom dataclasses import dataclass, field\n \n  \n \nempty_list = lambda : []\n \n  \n \n@dataclass\n \nclass Student:\n \n   grades:List[int] = field(default_factory=empty_list) # Initialize Student.grades to an empty list\n "}}